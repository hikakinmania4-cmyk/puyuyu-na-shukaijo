<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<!-- ã‚µã‚¤ãƒˆã®åŸºæœ¬æƒ…å ± -->
<title>ğŸ¥ºã·ã‚†ã‚†ãªé›†ä¼šå ´ğŸ¥º - ã·ã‚†ã‚†å¥½ãã®ãŸã‚ã®åŒ¿åæ²ç¤ºæ¿</title>
<meta name="description" content="ã·ã‚†ã‚†ğŸ¥ºå¥½ããŒã“ãã£ã¦é›†ã¾ã‚‹ã¨å™‚ã®æ²ç¤ºæ¿" />
<meta name="keywords" content="æ²ç¤ºæ¿,åŒ¿å,é›‘è«‡,è¶£å‘³,ã·ã‚†ã‚†" />

<!-- OGPã‚¿ã‚° (SNSãªã©ã§å…±æœ‰ã•ã‚ŒãŸã¨ãã®è¡¨ç¤º) -->
<meta property="og:title" content="ğŸ¥ºã·ã‚†ã‚†ãªé›†ä¼šå ´ğŸ¥º" />
<meta property="og:description" content="ã·ã‚†ã‚†ğŸ¥ºå¥½ããŒã“ãã£ã¦é›†ã¾ã‚‹ã¨å™‚ã®æ²ç¤ºæ¿" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://hikakinmania4-cmyk.github.io/puyuyu-na-shukaijo/" />
<meta property="og:image" content="https://i.ibb.co/93Stdh8x/96a86591b41f.jpg" />
<meta name="twitter:card" content="summary_large_image" />

<!-- ãã®ä»–ã®ãƒ¡ã‚¿ã‚¿ã‚° -->
<meta name="author" content="puyuyu" />
<meta name="theme-color" content="#1565c0" />

<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<style>
  :root{--primary:#1565c0;--accent:#0288d1;--bg:#f5f7fb;--card:#ffffff;--muted:#6b7280;--danger:#ef4444;--text-main:#111827;--text-muted:#6b7280;--border-color:#e5e7eb;}
  .dark-mode{--primary:#60a5fa;--accent:#38bdf8;--bg:#111827;--card:#1f2937;--muted:#9ca3af;--text-main:#f9fafb;--text-muted:#9ca3af;--border-color:#374151;}
  *{box-sizing:border-box}
  body{
    font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif;
    background:var(--bg);
    margin:0;
    padding:0;
    color:var(--text-main);
    transition:background-color .3s,color .3s;
  }
  header{background:linear-gradient(90deg,var(--primary),var(--accent));color:#fff;padding:12px 16px;display:flex;align-items:center;gap:12px;flex-wrap:wrap;}
  header h1{margin:0;font-size:18px;flex-grow:1;word-break:break-all;}
  header .controls{display:flex;gap:8px;align-items:center;}
  header .userbox{font-size:13px; margin-left: auto; text-align:right;}
  header button{background:rgba(255,255,255,0.14);border:none;color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer; display: inline-flex; align-items: center; gap: 6px; position:relative;}
  header button:hover{background:rgba(255,255,255,0.22)}
  .wrap{max-width:1000px;margin:16px auto;padding:12px}
  .card{background:var(--card);border-radius:10px;padding:12px;box-shadow:0 2px 6px rgba(2,6,23,0.06);margin-bottom:12px;border:1px solid var(--border-color); transition: background-color .3s, border-color .3s;}
  .card h2{margin:0 0 8px 0;font-size:16px;color:var(--primary);word-break:break-all;}
  .thread-header{display:flex;flex-wrap:nowrap;justify-content:space-between;align-items:flex-start;gap:16px;}
  .thread-header-main{min-width:0;flex-grow:1;}
  .thread-header-meta{text-align:right;flex-shrink:0;}
  input[type="text"],textarea,select{width:100%;padding:8px;border:1px solid var(--border-color);border-radius:8px;font-size:14px;background:var(--card);color:var(--text-main);}
  textarea{min-height:80px;resize:vertical}
  .btn{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;transition:background-color 0.2s;}
  .btn:disabled{background:var(--muted);cursor:not-allowed;}
  .btn.warn{background:var(--danger)}
  .btn.small{padding:6px 8px;font-size:13px;border-radius:6px}
  .btn.liked{background:#e11d48;color:white;}
  .search-box{display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap;}
  .sort-box{display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap; align-items: center;}
  .thread-item, .history-item{padding:10px;border-radius:8px;border:1px solid var(--border-color);display:flex;flex-wrap:nowrap;align-items:center;gap:12px; margin-bottom: 8px;}
  .thread-link{font-weight:600;color:var(--primary);text-decoration:none; display:block;word-break:break-all;}
  .thread-info{flex-grow:1; display:flex; flex-direction:column; gap: 4px; min-width:0; align-items:flex-start;}
  .history-item .thread-info {flex-direction:column; align-items:flex-start; gap: 4px;}
  .thread-tags{display:flex;flex-wrap:wrap;gap:4px;}
  .tag{background:var(--muted);color:var(--text-main);padding:2px 6px;border-radius:4px;font-size:11px;cursor:pointer; text-decoration: none;}
  .thread-title-wrapper{min-width:0;display:flex;align-items:center;gap:8px;}
  .thread-meta-info{display:flex;flex-direction:column;align-items:flex-end;flex-shrink:0;text-align:right;}
  .thread-preview-img{width:60px;height:60px;object-fit:cover;border-radius:6px;flex-shrink:0;}
  .meta{font-size:13px;color:var(--text-muted)}
  .post{padding:10px;border-top:1px solid var(--border-color);margin-top:8px;}
  #postsContainer > .post:first-child{margin-top:0;}
  .modal-body .post {border-top:none; border-bottom:1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 10px;}
  .modal-body .post:last-child {border-bottom:none; margin-bottom:0;}
  .post .meta{font-size:12px;color:var(--text-muted);display:flex;gap:8px;align-items:center;flex-wrap:wrap; margin-bottom: 8px;}
  .post .meta .no{color:var(--accent);cursor:pointer;font-weight:700}
  .post .meta .post-author{font-weight:bold;cursor:pointer; color: var(--text-main);}
  .post .body{white-space:pre-wrap;word-break:break-word}
  .post .body a{color:var(--primary);}
  .post-image{max-width:280px;height:auto;border-radius:6px;margin-top:8px;display:block;cursor:pointer}
  .highlight{background-color: yellow; color: black;}
  .controls{margin-top:8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
  .timestamp{margin-left:auto; white-space:nowrap;}
  .badge-op, .badge-level{background:var(--primary);color:white;padding:3px 6px;border-radius:999px;font-size:12px; white-space:nowrap;}
  .badge-new, .badge-anchor{display:inline-flex;align-items:center;justify-content:center;min-width:18px;height:18px;border-radius:999px;background:var(--danger);color:white;font-size:11px;font-weight:bold;padding:0 5px;}
  #historyUnreadBadge{position:absolute;top:-6px;right:-6px;line-height:1;box-shadow:0 1px 3px rgba(0,0,0,0.3);}
  .unread-notification{margin-top:4px;}
  .unread-notification .badge-new{font-size:12px;padding:3px 8px;}
  .badge-anchor{cursor:pointer;}
  .banned-note, .deleted-note, .ng-hidden-post{color:var(--danger);font-weight:700;margin-top:8px;}
  .ng-word-red{color:var(--danger);font-weight:bold;}
  .thread-link.ng-word-red { color: var(--danger); }
  .search-highlight {
    color: var(--danger);
    font-weight: bold;
    background-color: rgba(239, 68, 68, 0.1);
  }
  .dice-result {
    color: #ff8c00;
    font-weight: bold;
  }
  .small-muted{font-size:12px;color:var(--text-muted)}
  .modal-overlay,.lightbox-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:1000;}
  .modal-content{background:var(--bg);border-radius:10px;width:90%;max-width:600px;max-height:80%;display:flex;flex-direction:column;border:1px solid var(--border-color);}
  .modal-header{padding:12px 16px;border-bottom:1px solid var(--border-color);display:flex;justify-content:space-between;align-items:center;}
  .modal-header h2{font-size:18px;color:var(--primary);margin:0;}
  .modal-close-btn,.lightbox-close-btn{font-size:28px;background:none;border:none;cursor:pointer;color:white;position:absolute;top:10px;right:15px;}
  .modal-close-btn{color:var(--text-muted);position:static;}
  .modal-body{padding:16px;overflow-y:auto;}
  #profileId{color:var(--text-muted);font-size:13px;margin:0 0 12px 0;word-break:break-all;}
  #profileControls{margin-bottom:12px; border-top:1px solid var(--border-color); padding-top:12px; display:flex; gap:8px;}
  .lightbox-content img{max-width:90vw;max-height:90vh;display:block;}
  .vote-box{margin-top:10px; display:flex; flex-direction:column; gap: 5px;}
  .vote-option-bar-container{display: flex; align-items: center; gap: 8px; padding: 4px; border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer; transition: background-color .2s;}
  .vote-option-bar-container:hover{background-color: rgba(128,128,128,0.1);}
  .vote-option-bar-container.voted-by-user{border-color: var(--primary); background-color: rgba(21,101,192,0.08);}
  .vote-option-bar-container.expired{cursor:not-allowed;}
  .vote-option-bar-container.expired:hover{background-color: transparent;}
  .vote-label{flex-shrink: 0; font-size: 14px;}
  .vote-bar-wrapper{flex-grow: 1; background-color: var(--border-color); border-radius: 4px; height: 20px; overflow: hidden;}
  .vote-option-bar{background-color: var(--accent); height: 100%; transition: width .3s ease-out, background-color .3s;}
  .vote-result{font-size: 13px; font-weight: bold; min-width: 60px; text-align: right;}
  .pagination-controls{display:flex;justify-content:center;align-items:center;gap:12px;margin-top:16px;}
  @media(max-width:680px){header{justify-content:center;}header .userbox{width:100%;text-align:center;margin:4px 0;}}
</style>
</head>
<body>
  <header>
    <h1>ğŸ¥ºã·ã‚†ã‚†ãªé›†ä¼šå ´ğŸ¥º</h1>
    <div class="userbox"><span id="userDisplay"></span></div>
    <div class="controls">
      <button id="homeBtn">ğŸ  ãƒ›ãƒ¼ãƒ </button>
      <button id="historyBtn">ğŸ“œ å±¥æ­´<span id="historyUnreadBadge" class="badge-new" style="display:none;"></span></button>
      <button id="settingsBtn">âš™ï¸ è¨­å®š</button>
      <button id="themeToggleBtn">ğŸŒ™</button>
      <button id="refreshBtn">ğŸ”„ æ›´æ–°</button>
    </div>
  </header>
  <div class="wrap" id="app"></div>
  <div id="profileModal" class="modal-overlay"><div class="modal-content"><div class="modal-header"><h2 id="profileName"></h2><button id="closeProfileBtn" class="modal-close-btn">&times;</button></div><div class="modal-body"><p id="profileId"></p><div id="profileControls"></div><h3>ã“ã®äººã®æŠ•ç¨¿</h3><div id="profilePostsList"></div></div></div></div>
  <div id="imageLightbox" class="lightbox-overlay"><div class="lightbox-content"><img id="lightboxImage" src=""><button id="lightboxClose" class="lightbox-close-btn">&times;</button></div></div>
  <div id="voteModal" class="modal-overlay"><div class="modal-content"><div class="modal-header"><h2>ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆä½œæˆ</h2><button id="closeVoteModalBtn" class="modal-close-btn">&times;</button></div><div class="modal-body"><h4>æŠ•ç¥¨æœŸé™</h4><select id="voteDeadlineSelect" style="width:100%;margin-bottom:12px;"><option value="0">ç„¡æœŸé™</option><option value="60000">1åˆ†</option><option value="180000">3åˆ†</option><option value="300000">5åˆ†</option><option value="900000">15åˆ†</option><option value="1800000">30åˆ†</option><option value="3600000">1æ™‚é–“</option><option value="21600000">6æ™‚é–“</option><option value="86400000">1æ—¥</option><option value="259200000">3æ—¥</option></select><h4>é¸æŠè‚¢</h4><div id="voteOptionsContainer"><input type="text" class="vote-option-input" placeholder="é¸æŠè‚¢1" style="margin-bottom:8px;"><input type="text" class="vote-option-input" placeholder="é¸æŠè‚¢2" style="margin-bottom:8px;"></div><button id="addVoteOptionBtn" class="btn small">é¸æŠè‚¢ã‚’è¿½åŠ </button><div style="text-align:right; margin-top:16px;"><button id="insertVoteBtn" class="btn">æœ¬æ–‡ã«æŒ¿å…¥</button></div></div></div></div>
  <div id="anchorModal" class="modal-overlay"><div class="modal-content"><div class="modal-header"><h2>ã“ã®æŠ•ç¨¿ã¸ã®è¿”ä¿¡</h2><button id="closeAnchorModalBtn" class="modal-close-btn">&times;</button></div><div class="modal-body" id="anchorModalBody"></div></div></div>
  
  <audio id="notificationSound" src="https://soundeffect-lab.info/sound/anime/mp3/pororin1.mp3" preload="auto"></audio>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyDS3Tlr9Oc4z5Kz2Zg72p9VRayPSAbmwTw",
  authDomain: "config-f5509.firebaseapp.com",
  databaseURL: "https://config-f5509-default-rtdb.firebaseio.com",
  projectId: "config-f5509",
  storageBucket: "config-f5509.appspot.com",
  messagingSenderId: "513023904601",
  appId: "1:513023904601:web:1846aa87aec5de306e1a48",
  measurementId: "G-KT2LZC2EED"
};
const NG_WORDS = ['ë°”ë³´', 'ë©ì²­ì´', 'ì£½ì–´', 'æ­»ã­', 'ãƒã‚«', 'é¦¬é¹¿', 'kill', 'idiot'];
const ADMIN_IDS = ['W4ZZKXRY9CS'];
document.addEventListener('DOMContentLoaded', () => { main(); });

function main() {
  if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_API_KEY") {
    document.getElementById('app').innerHTML = `<div class="card"><h2>ğŸš¨ è¨­å®šãŒå¿…è¦ã§ã™ï¼</h2><p>HTMLãƒ•ã‚¡ã‚¤ãƒ«å†…ã® <code>firebaseConfig</code> ãŒæœªè¨­å®šã§ã™ã€‚</p></div>`; return;
  }
  try { firebase.initializeApp(firebaseConfig); } catch (e) { alert("Firebaseã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); return; }
  const db = firebase.database();

  let globalBanList = {};
  let myTotalExp = 0;
  let loadingInterval = null;
  let currentEditState = null;

  const banRef = db.ref('globalBan');
  banRef.on('value', (snapshot) => {
      globalBanList = snapshot.val() || {};
      const currentThreadId = location.hash.startsWith('#thread-') ? location.hash.replace('#thread-','') : null;
      if (currentThreadId && document.getElementById('postsContainer')) {
          Promise.all([
              db.ref('threads/' + currentThreadId).once('value'),
              db.ref('userLevels').once('value')
          ]).then(([threadSnapshot, userLevelsSnapshot]) => {
              const threadData = threadSnapshot.val();
              const userLevels = userLevelsSnapshot.val() || {};
              if (threadData) { }
          });
      }
  });

  let activeDataListener = null, activeViewersListener = null, myConnectionRef = null, allThreads = [], currentViewers = 0, currentPage = 1;
  let activeUnreadListeners = [];
  let unreadStatus = {};
  let repliesToMe = {};
  let myPostNumbersCache = {};
  let threadDataCache = {};
  let userLevelsCache = {}; 
  let appActionListener = null;

  const THREADS_PER_PAGE = 15;
  const THUMBNAIL_WIDTH = 120;
  const THUMBNAIL_HEIGHT = 120;
  const THUMBNAIL_QUALITY = 0.7;

  function cleanupListeners() {
    if(activeDataListener){
        if (Array.isArray(activeDataListener)) {
            activeDataListener.forEach(l => l.ref.off(l.type, l.callback));
        } else if (activeDataListener.ref && activeDataListener.callback) {
            activeDataListener.ref.off('value', activeDataListener.callback);
        }
        activeDataListener = null;
    }
    if(activeViewersListener){ activeViewersListener.ref.off('value', activeViewersListener.callback); activeViewersListener = null; }
    if(myConnectionRef){ myConnectionRef.remove(); myConnectionRef = null; }
    const appContainer = document.getElementById('app');
    if (appActionListener && appContainer) {
        appContainer.removeEventListener('click', appActionListener);
        appActionListener = null;
    }
  }
  const PERMANENT_ID_COOKIE = 'puyuyun_permanent_id_v2';
  const DAILY_ID_COOKIE = 'puyuyun_daily_id_v2';
  const USERNAME_COOKIE = 'puyuyun_username_v1';
  const LAST_POST_TIME_KEY = 'puyuyun_last_post_time';
  const POST_INTERVAL_SECONDS = 10;
  const MAX_IMAGE_BYTES = 10 * 1024 * 1024;
  const POST_LIMIT = 1000;
  const TITLE_LIMIT = 25;
  const NAME_LIMIT = 11;
  const TEXT_LIMIT = 1000;
  const MAX_NEWLINES = 15;
  const MAX_CONSECUTIVE_NEWLINES = 2;
  const VOTE_OPTION_LIMIT = 15;
  const HISTORY_KEY = 'puyuyun_history_v1';
  const THEME_KEY = 'puyuyun_theme';
  const NAME_HISTORY_KEY = 'puyuyun_name_history_v1';
  const NG_SETTINGS_KEY = 'puyuyun_ng_settings_v1';
  const SOUND_SETTINGS_KEY = 'puyuyun_sound_settings_v1';
  const NEXT_THREAD_DATA_KEY = 'puyuyun_next_thread_data';
  const DAILY_ACTIVITY_KEY = 'puyuyun_daily_activity_v1';
  
  const TITLE_THRESHOLDS = {
    1000: 'æœ€å¼·ã®ã€ãŠã§ğŸ˜ƒ',
    60: 'ã‚†ã‚ã¡ã‚ƒã‚“ğŸ¤¥',
    30: 'ã¦ã‚Šã‚ŠğŸ˜ ',
    10: 'ã·ã‚†ã‚†ğŸ¥º',
    0: 'ãƒŸãƒ‹ãƒ¯ã‚¤ğŸ¥¹'
  };

  const REACTION_PAIRS = { 'ğŸ¥º': 'ğŸ¥¹', 'ğŸ˜': 'ğŸ¤“', 'ğŸ˜…': 'ğŸ˜“' };
  const BASE_REACTIONS = Object.keys(REACTION_PAIRS);
  
  function startLoadingAnimation(element, text = 'èª­ã¿è¾¼ã¿ä¸­') {
    if (loadingInterval) clearInterval(loadingInterval);

    const emojiSequence = ['ğŸ¥º', 'ğŸŒ”', 'ğŸŒ“', 'ğŸŒ’', 'ğŸŒ‘', 'ğŸŒ˜', 'ğŸŒ—', 'ğŸŒ–', 'ğŸ¤¡'];
    let currentIndex = 0;
    
    const textSpan = document.createElement('span');
    textSpan.textContent = `${text}â€¦ `;
    const emojiSpan = document.createElement('span');
    emojiSpan.textContent = emojiSequence[currentIndex];
    
    element.innerHTML = ''; 
    element.appendChild(textSpan);
    element.appendChild(emojiSpan);
    
    loadingInterval = setInterval(() => {
      currentIndex = (currentIndex + 1) % emojiSequence.length;
      emojiSpan.textContent = emojiSequence[currentIndex];
    }, 150);
  }

  function stopLoadingAnimation() {
      if (loadingInterval) {
          clearInterval(loadingInterval);
          loadingInterval = null;
      }
  }
  
  function loadNameHistory() { try { return JSON.parse(localStorage.getItem(NAME_HISTORY_KEY)) || []; } catch(e) { return []; } }
  function saveNameHistory(history) { localStorage.setItem(NAME_HISTORY_KEY, JSON.stringify(history)); }
  function loadNgSettings() { try { return JSON.parse(localStorage.getItem(NG_SETTINGS_KEY)) || {}; } catch(e) { return {}; } }
  function saveNgSettings(settings) { localStorage.setItem(NG_SETTINGS_KEY, JSON.stringify(settings)); }
  function loadSoundSettings() { try { return JSON.parse(localStorage.getItem(SOUND_SETTINGS_KEY)) || { enabled: true }; } catch(e) { return { enabled: true }; } }
  function saveSoundSettings(settings) { localStorage.setItem(SOUND_SETTINGS_KEY, JSON.stringify(settings)); }
  function loadDailyActivity() { try { return JSON.parse(localStorage.getItem(DAILY_ACTIVITY_KEY)) || { date: '', postCount: 0 }; } catch(e) { return { date: '', postCount: 0 }; } }
  function saveDailyActivity(activity) { localStorage.setItem(DAILY_ACTIVITY_KEY, JSON.stringify(activity)); }

  function uid(l=10){return Math.random().toString(36).slice(2,2+l).toUpperCase();}
  function setCookie(n,v,d=365){const e=new Date();e.setTime(e.getTime()+(d*24*60*60*1000));document.cookie=`${n}=${encodeURIComponent(v)};expires=${e.toUTCString()};path=/;SameSite=Lax;Secure`;}
  function getCookie(n){const kv=document.cookie.split(';').map(s=>s.trim()).find(s=>s.startsWith(n+'='));return kv?decodeURIComponent(kv.split('=')[1]):null;}
  function escapeHTML(s){if(s==null)return '';return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;');}
  function formatTimestamp(ts) {
    const d = new Date(ts);
    const M = (d.getMonth() + 1).toString().padStart(2, '0');
    const D = d.getDate().toString().padStart(2, '0');
    const h = d.getHours().toString().padStart(2, '0');
    const m = d.getMinutes().toString().padStart(2, '0');
    return `${M}/${D} ${h}:${m}`;
  }
  function formatTimeLeft(timeLeft) {
    if (timeLeft <= 0) return 'ç· ã‚åˆ‡ã‚Š';
    const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
    const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
    let timeString = '';
    if (days > 0) timeString += `${days}æ—¥ `;
    if (hours > 0 || days > 0) timeString += `${String(hours).padStart(2,'0')}:`;
    timeString += `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
    return timeString;
  }
  function getJstDateString() {
    const now = new Date();
    const formatter = new Intl.DateTimeFormat('en-CA', {
      timeZone: 'Asia/Tokyo',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    });
    return formatter.format(now);
  }
  
  function getMomentumScore(thread) {
    let score = 0;
    const now = Date.now();
    const minutesSinceLastPost = (now - thread.lastUpdatedAt) / (1000 * 60);
    if (minutesSinceLastPost < 1) score += 50;
    else if (minutesSinceLastPost < 10) score += 20;
    else if (minutesSinceLastPost < 60) score += 5;

    const viewers = thread.viewerCount || 0;
    if (viewers >= 10) score += 40;
    else if (viewers >= 5) score += 20;
    else if (viewers >= 3) score += 10;
    
    return score;
  }

  function getMomentumEmoji(thread) {
    if (thread.tags && thread.tags.includes('ãƒ¬ãƒ™ãƒ«ä¸Šã’')) {
        return '';
    }
    const score = getMomentumScore(thread);
    if (score >= 70) return 'ğŸš€';
    if (score >= 40) return 'ğŸ”¥ğŸ”¥ğŸ”¥';
    if (score >= 20) return 'ğŸ”¥ğŸ”¥';
    if (score >= 1) return 'ğŸ”¥';
    return '';
  }

  function renderContent(s, post = null) {
    let content = escapeHTML(s);
    if(content.match(/javascript:/i)) return '[XSS Alert]';
    
    content = content.replace(/&gt;&gt;(\d+)/g, '<a href="#" data-action="quote" data-num="$1">&gt;&gt;$1</a>');
    
    const urlRegex = /(https?:\/\/[^\s<>"'()]+)/g;
    content = content.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
    
    let voteIndex = 0;
    const voteRegex = /\[vote\((\d+)\):([^\]]+)\]/g;
    content = content.replace(voteRegex, (match, p1, p2) => {
        const deadlineTimestamp = parseInt(p1, 10);
        const options = p2.split(',').map(opt => opt.trim());
        const isExpired = deadlineTimestamp > 0 && Date.now() > deadlineTimestamp;

        const voteId = post ? `vote-${post.id}-${voteIndex++}` : `vote-preview-${voteIndex++}`;
        const threadId = location.hash.startsWith('#thread-') ? location.hash.replace('#thread-', '') : null;

        if (!post || !threadId) {
            return `<div class="vote-box">${options.map(opt => `<button class="btn small" disabled>${escapeHTML(opt)}</button>`).join(' ')}</div>`;
        }
        
        const currentUser = getUser();
        const votes = post.votes || {};
        const myVote = votes[currentUser.permanentId];
        
        let voteCounts = {};
        options.forEach(opt => { voteCounts[opt] = 0; });
        Object.values(votes).forEach(votedOption => {
            if (voteCounts[votedOption] !== undefined) voteCounts[votedOption]++;
        });
        
        const totalVotes = Object.values(voteCounts).reduce((sum, count) => sum + count, 0);

        let headerHtml = '';
        if (isExpired) {
            headerHtml = `<div class="small-muted" style="margin-bottom:8px; text-align:center; font-weight:bold;">ã“ã®ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆã¯ç· ã‚åˆ‡ã‚‰ã‚Œã¾ã—ãŸ</div>`;
        } else if (deadlineTimestamp > 0) {
            const timeLeft = deadlineTimestamp - Date.now();
            const initialCountdownText = formatTimeLeft(timeLeft);
            headerHtml = `<div class="small-muted" style="margin-bottom:8px; text-align:center; font-weight:bold;">
                            <span>â° æŠ•ç¥¨çµ‚äº†ã¾ã§: </span>
                            <span class="vote-countdown" data-deadline="${deadlineTimestamp}">${initialCountdownText}</span>
                        </div>`;
        }
        
        const optionsHtml = options.map(opt => {
            const count = voteCounts[opt] || 0;
            const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
            const isVotedByUser = myVote === opt;
            const containerClass = `vote-option-bar-container ${isVotedByUser ? 'voted-by-user' : ''} ${isExpired ? 'expired' : ''}`;
            const dataAction = isExpired ? '' : `data-action="vote" data-thread-id="${threadId}" data-post-id="${post.id}" data-vote-option="${escapeHTML(opt)}"`;

            return `
                <div class="${containerClass}" ${dataAction}>
                    <span class="vote-label">${escapeHTML(opt)}</span>
                    <div class="vote-bar-wrapper">
                        <div class="vote-option-bar" style="width: ${percentage}%;"></div>
                    </div>
                    <span class="vote-result">${count}ç¥¨ (${percentage.toFixed(1)}%)</span>
                </div>
            `;
        }).join('');

        return `<div class="vote-box" id="${voteId}">${headerHtml}${optionsHtml}</div>`;
    });

    const diceResultRegex = /\[(\d+D\d+)=([\d\s]+)\s\(([\d,\s]+)\)\]/g;
    content = content.replace(diceResultRegex, (match, type, sum, rolls) => {
        if (rolls.includes(',')) {
            const highlightedRolls = rolls.replace(/(\d+)/g, `<span class="dice-result">$1</span>`);
            return `<span class="dice-result">${sum}</span> (${highlightedRolls})`;
        } else {
            return `<span class="dice-result">${sum}</span>`;
        }
    });

    return content.replace(/\n/g, '<br>');
  }
  
  function ensureUser() {
    let permanentId = getCookie(PERMANENT_ID_COOKIE);
    if (!permanentId) {
      const oldId = getCookie('puyuyun_permanent_id_v1');
      if (oldId) {
        permanentId = oldId;
        setCookie(PERMANENT_ID_COOKIE, permanentId, 365 * 10);
      } else {
        permanentId = uid(16);
        setCookie(PERMANENT_ID_COOKIE, permanentId, 365 * 10);
      }
    }
    const todayStr = new Date().toISOString().slice(0, 10);
    let dailyInfo = {}; try { dailyInfo = JSON.parse(getCookie(DAILY_ID_COOKIE) || '{}'); } catch (e) {}
    if (dailyInfo.date !== todayStr || !dailyInfo.id) { dailyInfo = { id: uid(8), date: todayStr }; setCookie(DAILY_ID_COOKIE, JSON.stringify(dailyInfo), 1); }
    
    let username = getCookie(USERNAME_COOKIE) || 'ãã®ã¸ã‚“ã®ãƒŸãƒ‹ãƒ¯ã‚¤ğŸ¥¹';
    
    return { permanentId, id: dailyInfo.id, name: username };
  }
  
  function getLevel(exp) {
    const level = exp + 1;
    let title = TITLE_THRESHOLDS[0]; // Default title
    
    const sortedThresholds = Object.keys(TITLE_THRESHOLDS).map(Number).sort((a, b) => b - a);
    
    for (const threshold of sortedThresholds) {
      if (exp >= threshold) {
        title = TITLE_THRESHOLDS[threshold];
        break;
      }
    }
    return { level: level, title: title };
  }
  function setUserName(n){
      if (n.length > NAME_LIMIT) {
        alert(`åå‰ã¯${NAME_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
        return false;
      }
      setCookie(USERNAME_COOKIE, n, 365);
      
      const history = loadNameHistory();
      const newHistory = history.filter(item => item.name !== n);
      newHistory.unshift({ name: n, changedAt: Date.now() });
      if (newHistory.length > 20) newHistory.pop();
      saveNameHistory(newHistory);

      refreshHeader();
      const newNameInput = document.getElementById('newName');
      if (newNameInput) newNameInput.value = n;
      const replyNameInput = document.getElementById('replyName');
      if (replyNameInput) replyNameInput.value = n;
      return true;
  }
  function getUser(){return ensureUser();}
  function refreshHeader(){document.getElementById('userDisplay').textContent=`ã‚ãªãŸ: ${getUser().name}`;}
  function loadHistory(){try{return JSON.parse(localStorage.getItem(HISTORY_KEY))||[];}catch(e){return [];}}
  function saveHistory(h){localStorage.setItem(HISTORY_KEY,JSON.stringify(h));}
  function addToHistory(id,title,lastUpdatedAt){let h=loadHistory();h=h.filter(i=>i.id!==id);h.unshift({id,title,lastUpdatedAt,visitedAt:Date.now()});if(h.length>50)h.pop();saveHistory(h);}
  function removeFromHistory(id){let h=loadHistory();h=h.filter(i=>i.id!==id);saveHistory(h);}
  function goHome(){ location.href = location.pathname; }

  function displayThreads(threadsToDisplay, sortMode = 'newPost', tagFilter = null, isReversed = false, page = 1, searchTerm = null) {
    const c = document.getElementById('threadListContainer'); 
    const p = document.getElementById('paginationContainer');
    if(!c || !p) return;

    const ngSettings = loadNgSettings();
    const hideWords = Object.keys(ngSettings).filter(word => ngSettings[word] === 'hide');
    const redWords = Object.keys(ngSettings).filter(word => ngSettings[word] === 'red');

    let displayableThreads = threadsToDisplay;

    if (sortMode === 'manyRes') {
        displayableThreads = displayableThreads.filter(t => t.postCounter < POST_LIMIT);
    }
    
    if (tagFilter) {
      displayableThreads = displayableThreads.filter(t => (t.tags || []).includes(tagFilter));
    }
    
    let sortedThreads = [...displayableThreads].sort((a, b) => {
      if (sortMode === 'newPost') return b.lastUpdatedAt - a.lastUpdatedAt;
      if (sortMode === 'newThread') return b.createdAt - a.createdAt;
      if (sortMode === 'manyRes') return (b.postCounter || 0) - (a.postCounter || 0);
      if (sortMode === 'momentum') {
        const scoreA = getMomentumScore(a);
        const scoreB = getMomentumScore(b);
        return scoreB - scoreA;
      }
      return 0;
    });

    if (isReversed) {
        sortedThreads.reverse();
    }

    const threadsAfterNgFilter = sortedThreads.filter(t => {
        return !hideWords.some(word => t.title.toLowerCase().includes(word.toLowerCase()));
    });
    
    const totalPages = Math.max(1, Math.ceil(threadsAfterNgFilter.length / THREADS_PER_PAGE));
    currentPage = Math.min(page, totalPages);
    
    const startIndex = (currentPage - 1) * THREADS_PER_PAGE;
    const endIndex = startIndex + THREADS_PER_PAGE;
    const pagedThreads = threadsAfterNgFilter.slice(startIndex, endIndex);

    if(pagedThreads.length===0){
      c.innerHTML=`<div class="small-muted">${tagFilter ? `ã‚¿ã‚°ã€Œ${escapeHTML(tagFilter)}ã€ãŒä»˜ã„ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚` : 'è©²å½“ã™ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“'}</div>`;
      p.innerHTML = '';
    } else {
      c.innerHTML='';
      pagedThreads.forEach(t=>{
        const postCount = t.postCounter || 0;
        const momentumEmoji = getMomentumEmoji(t);
        const imgHtml = t.previewImg ? `<img src="${t.previewImg}" class="thread-preview-img" alt="preview">` : '';
        const tagsHtml = (t.tags || []).map(tag => `<a href="#" class="tag" data-tag="${escapeHTML(tag)}">${escapeHTML(tag)}</a>`).join('');
        
        const titleContainsRedWord = redWords.some(word => t.title.toLowerCase().includes(word.toLowerCase()));
        const titleClass = titleContainsRedWord ? 'thread-link ng-word-red' : 'thread-link';
        let displayTitle = escapeHTML(t.title.replace(/#[\p{L}\p{N}_]+/ug, ''));
        const lockIcon = t.levelRestriction > 0 ? 'ğŸ”’' : '';

        if (searchTerm && searchTerm.trim() !== '') {
          try {
            const regex = new RegExp(escapeHTML(searchTerm.trim()).replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            displayTitle = displayTitle.replace(regex, `<span class="search-highlight">$&</span>`);
          } catch (e) { /* Invalid regex, do nothing */ }
        }

        const i=document.createElement('div');
        i.className='thread-item';
        i.innerHTML=`
          ${imgHtml}
          <div class="thread-info">
            <div class="thread-title-wrapper">
              <a class="${titleClass}" href="#thread-${t.id}">${lockIcon}${displayTitle}</a>
            </div>
            <div class="thread-tags">${tagsHtml}</div>
          </div>
          <div class="thread-meta-info">
            <div class="meta">${postCount}ãƒ¬ã‚¹</div>
            <div class="meta">${momentumEmoji}</div>
          </div>`;
        c.appendChild(i);
      });
      document.querySelectorAll('.tag').forEach(tagEl => {
        tagEl.onclick = (e) => {
            e.preventDefault();
            const tag = e.target.dataset.tag;
            document.getElementById('searchInput').value = `#${tag}`;
            document.getElementById('searchBtn').click();
        };
      });

      p.innerHTML = `
        <div class="pagination-controls">
          <button id="prevPageBtn" class="btn small" ${currentPage === 1 ? 'disabled' : ''}>å‰ã¸</button>
          <span class="small-muted">${currentPage} / ${totalPages} ãƒšãƒ¼ã‚¸</span>
          <button id="nextPageBtn" class="btn small" ${currentPage === totalPages ? 'disabled' : ''}>æ¬¡ã¸</button>
        </div>
      `;
      document.getElementById('prevPageBtn').onclick = () => { if(currentPage > 1) { currentPage--; window.performDisplay(); } };
      document.getElementById('nextPageBtn').onclick = () => { if(currentPage < totalPages) { currentPage++; window.performDisplay(); } };
    }
  }
  
  function renderHome() {
    currentPage = 1; 
    document.getElementById('app').innerHTML = `<div class="card"><h2>æ–°ã—ã„ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½œæˆ</h2><input id="newTitle" type="text" placeholder="ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆ#ã‚¿ã‚° ã§ã‚¿ã‚°ä»˜ã‘ã§ãã¾ã™ï¼‰" style="margin-bottom:8px;"><input id="newName" type="text" placeholder="åå‰ï¼ˆä»»æ„ï¼‰" value="${escapeHTML(getUser().name)}" style="margin-bottom:8px;"><textarea id="newText" placeholder="æœ¬æ–‡ (å¿…é ˆ)"></textarea><div class="controls" style="justify-content:flex-start; margin-top:8px;"><button id="createVoteBtn" class="btn small">ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆä½œæˆ</button></div>
    <div style="margin-top:8px;"><label for="levelRestrictionSelect" class="small-muted">ãƒ¬ãƒ™ãƒ«åˆ¶é™:</label><select id="levelRestrictionSelect"><option value="0">ç„¡åˆ¶é™</option><option value="10">Lv.10ä»¥ä¸Š</option><option value="30">Lv.30ä»¥ä¸Š</option><option value="60">Lv.60ä»¥ä¸Š</option><option value="250">Lv.250ä»¥ä¸Š</option><option value="500">Lv.500ä»¥ä¸Š</option><option value="1000">Lv.1000ä»¥ä¸Š</option></select></div>
    <div style="margin-top:8px; display:flex; justify-content:space-between; align-items:center;"><input id="newImage" type="file" accept="image/*"><button class="btn" id="createThreadBtn">ã‚¹ãƒ¬ä½œæˆ</button></div></div><div class="card"><h2>ã‚¹ãƒ¬ãƒƒãƒ‰ä¸€è¦§</h2><div class="search-box"><input type="text" id="searchInput" placeholder="ã‚¿ã‚¤ãƒˆãƒ«æ¤œç´¢ or #ã‚¿ã‚°å"><button id="searchBtn" class="btn small">æ¤œç´¢</button><button id="clearSearchBtn" class="btn small">ã‚¯ãƒªã‚¢</button></div><div class="sort-box"><span class="small-muted">ä¸¦ã³æ›¿ãˆ:</span><select id="sortSelect"><option value="newPost" selected>æ–°ç€ãƒ¬ã‚¹é †</option><option value="newThread">ã‚¹ãƒ¬ç«‹ã¦é †</option><option value="manyRes">ãƒ¬ã‚¹æ•°é †</option><option value="momentum">å‹¢ã„é †</option></select><label for="sortReverseCheckbox" class="small-muted" style="display:flex;align-items:center;gap:4px;"><input type="checkbox" id="sortReverseCheckbox">é€†é †</label></div><div id="threadListContainer"></div><div id="paginationContainer"></div></div>`;
    
    const threadListContainer = document.getElementById('threadListContainer');
    startLoadingAnimation(threadListContainer);
    
    const sortSelect = document.getElementById('sortSelect');
    const searchInput = document.getElementById('searchInput');
    const reverseCheckbox = document.getElementById('sortReverseCheckbox');

    window.performDisplay = () => {
        stopLoadingAnimation();
        const sortMode = sortSelect.value;
        const searchTerm = searchInput.value.trim();
        const isReversed = reverseCheckbox.checked;
        
        let threadsForDisplay;
        if (searchTerm.toLowerCase() === '#ãƒ¬ãƒ™ãƒ«ä¸Šã’') {
            threadsForDisplay = allThreads;
        } else {
            threadsForDisplay = allThreads.filter(t => !(t.tags || []).includes('ãƒ¬ãƒ™ãƒ«ä¸Šã’'));
        }

        if (searchTerm.startsWith('#')) {
            const tag = searchTerm.substring(1);
            const taggedThreads = threadsForDisplay.filter(t => (t.tags || []).includes(tag));
            displayThreads(taggedThreads, sortMode, tag, isReversed, currentPage, null);
        } else {
            const filtered = searchTerm ? threadsForDisplay.filter(t => t.title.toLowerCase().includes(searchTerm.toLowerCase())) : threadsForDisplay;
            displayThreads(filtered, sortMode, null, isReversed, currentPage, searchTerm);
        }
    }

    sortSelect.onchange = () => { currentPage = 1; performDisplay(); };
    reverseCheckbox.onchange = performDisplay;
    document.getElementById('searchBtn').onclick = () => { currentPage = 1; performDisplay(); };
    document.getElementById('clearSearchBtn').onclick=()=>{ searchInput.value=''; currentPage = 1; performDisplay(); };
    searchInput.onkeydown=(e)=>{if(e.key==='Enter') { currentPage = 1; performDisplay(); }};
    
    document.getElementById('createThreadBtn').onclick=async()=>{
      const b=document.getElementById('createThreadBtn');
      try{
        const u=getUser();
        if (globalBanList[u.permanentId]) {
          throw new Error('ã‚ãªãŸã¯ã“ã®æ²ç¤ºæ¿ã‹ã‚‰è¿½æ”¾ã•ã‚Œã¦ã„ã¾ã™ã€‚');
        }

        const t=document.getElementById('newTitle').value.trim(),n=document.getElementById('newName').value.trim();
        let rawText = document.getElementById('newText').value;
        
        rawText = processDiceCommands(rawText);

        const x = rawText.trim();
        const levelRestriction = parseInt(document.getElementById('levelRestrictionSelect').value, 10);

        const titleWithoutTags=t.replace(/#[\p{L}\p{N}_]+/ug,'').trim();
        if(!titleWithoutTags||!x)throw new Error('ã‚¿ã‚¤ãƒˆãƒ«æœ¬æ–‡ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        if(t.length>TITLE_LIMIT)throw new Error(`ã‚¿ã‚¤ãƒˆãƒ«ã¯${TITLE_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
        if(x.length>TEXT_LIMIT)throw new Error(`æœ¬æ–‡ã¯${TEXT_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
        if((rawText.match(/\n/g) || []).length > MAX_NEWLINES) throw new Error(`æ”¹è¡Œã¯${MAX_NEWLINES}å›ã¾ã§ã§ã™ã€‚`);
        if(rawText.match(new RegExp(`\\n{${MAX_CONSECUTIVE_NEWLINES + 1},}`))) throw new Error(`é€£ç¶šã—ãŸæ”¹è¡Œã¯${MAX_CONSECUTIVE_NEWLINES}å›ã¾ã§ã§ã™ã€‚`);
        if(n.length>NAME_LIMIT)throw new Error(`åå‰ã¯${NAME_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
        if(containsNGWord(t)||containsNGWord(x)||containsNGWord(n))throw new Error('ä¸é©åˆ‡ãªå˜èªãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚');
        const f=document.getElementById('newImage').files[0];
        b.disabled=true;b.textContent='ä½œæˆä¸­...';
        if(n&&n!==u.name){if(!setUserName(n))throw new Error(`åå‰ã¯${NAME_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);}
        
        const { full, thumb } = f ? await processImage(f) : { full: null, thumb: null };
        
        const threadRef=db.ref('threads').push();
        const threadId = threadRef.key;
        const firstPostId = threadRef.key;
        
        const tags=t.match(/#[\p{L}\p{N}_]+/ug)?.map(tag=>tag.substring(1))||[];
        const now=Date.now();
        
        const newThreadData={id:threadId,title:t,createdAt:now,lastUpdatedAt:now,op:u,posts:{[firstPostId]:{id:firstPostId,author:u,text:x,img:full,createdAt:now}},postCounter:1,tags:tags};
        if (levelRestriction > 0) {
            newThreadData.levelRestriction = levelRestriction;
        }

        const threadMetadata = {
            id: threadId,
            title: t,
            createdAt: now,
            lastUpdatedAt: now,
            op: u,
            postCounter: 1,
            tags: tags,
            levelRestriction: levelRestriction,
            viewerCount: 0,
            previewImg: thumb
        };
        
        const updates = {};
        updates[`/threads/${threadId}`] = newThreadData;
        updates[`/threadMetadata/${threadId}`] = threadMetadata;
        updates[`/userPosts/${u.permanentId}/${firstPostId}`] = { threadId: threadId, createdAt: now };

        await db.ref().update(updates);
        localStorage.setItem(LAST_POST_TIME_KEY,now.toString());

        const userLevelsSnapshot = await db.ref('userLevels').once('value');
        const userLevels = userLevelsSnapshot.val() || {};
        sessionStorage.setItem('new_thread_package', JSON.stringify({ threadData: newThreadData, userLevels: userLevels }));
        location.hash='thread-'+threadId;
      }catch(e){
        alert('ã‚¨ãƒ©ãƒ¼: '+e.message);
        if(b){b.disabled=false;b.textContent='ã‚¹ãƒ¬ä½œæˆ';}
      }
    };
    setupVoteModal('newText');

    const nextThreadDataJSON = localStorage.getItem(NEXT_THREAD_DATA_KEY);
    if (nextThreadDataJSON) {
        try {
            const nextThreadData = JSON.parse(nextThreadDataJSON);
            document.getElementById('newTitle').value = nextThreadData.title;
            document.getElementById('newText').value = nextThreadData.text;
            localStorage.removeItem(NEXT_THREAD_DATA_KEY);
        } catch(e) {
            localStorage.removeItem(NEXT_THREAD_DATA_KEY);
        }
    }
  }
  
  function renderHistoryPage() {
    document.getElementById('app').innerHTML = `<div class="card"><h2>ğŸ“œ é–²è¦§å±¥æ­´</h2><div id="historyListContainer"></div></div>`;
    const c = document.getElementById('historyListContainer');
    startLoadingAnimation(c, 'å±¥æ­´ã‚’èª­ã¿è¾¼ã¿ä¸­');

    db.ref('threadMetadata').once('value').then(snapshot => {
        const existingThreads = snapshot.val() || {};
        const history = loadHistory();
        stopLoadingAnimation();

        if (history.length === 0) {
            c.innerHTML = '<div class="small-muted">ã¾ã é–²è¦§å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</div>';
            return;
        }

        c.innerHTML = '';
        history.forEach((item) => {
            const isDeleted = !existingThreads[item.id];
            const unreadCount = unreadStatus[item.id] || 0;
            const unreadHtml = `<div class="unread-notification" id="unread-container-${item.id}" ${unreadCount > 0 ? '' : 'style="display:none;"'}>
                                    <span class="badge-new" id="unread-badge-${item.id}">ã‚ãªãŸã¸ã®æ–°ç€ãƒ¬ã‚¹: ${unreadCount}ä»¶</span>
                                </div>`;

            const linkHref = isDeleted ? 'javascript:void(0);' : `#thread-${item.id}`;
            const titleStyle = isDeleted ? 'color: var(--text-muted); text-decoration: line-through;' : '';
            const titleText = `${escapeHTML(item.title)} ${isDeleted ? '(å‰Šé™¤æ¸ˆã¿)' : ''}`;

            const i = document.createElement('div');
            i.className = 'history-item';
            i.innerHTML = `
                <div class="thread-info">
                    <a class="thread-link" href="${linkHref}" style="${titleStyle}">${titleText}</a>
                    ${unreadHtml}
                </div>
                <div class="thread-meta-info">
                    <div class="small-muted">${formatTimestamp(item.visitedAt)}</div>
                </div>`;
            c.appendChild(i);
        });
    }).catch(e => {
        console.error(e);
        stopLoadingAnimation();
        c.innerHTML = '<div class="banned-note">å±¥æ­´ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</div>';
    });
  }

  async function renderSettingsPage() {
    cleanupListeners();
    const user = getUser();

    myTotalExp = (await db.ref(`userLevels/${user.permanentId}/exp`).once('value')).val() || 0;
    const userLevel = getLevel(myTotalExp);
    const soundSettings = loadSoundSettings();

    document.getElementById('app').innerHTML = `
      <div class="card">
        <h2>ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«è¨­å®š</h2>
        <div style="display:flex; gap:8px; margin-bottom:12px;">
          <input type="text" id="settingsNameInput" value="${escapeHTML(user.name)}" placeholder="æ–°ã—ã„åå‰">
          <button id="settingsSaveNameBtn" class="btn small">å¤‰æ›´</button>
        </div>
        <div style="font-size:13px; display:flex; flex-direction:column; gap:8px;">
          <div style="font-weight:bold;">ã‚ãªãŸã®ç§°å·: <span class="badge-level">${userLevel.title}</span> (Lv. ${userLevel.level})</div>
          <div style="display:flex; align-items:center; gap:8px;">
            <span>Permanent ID: ${user.permanentId}</span>
            <button class="btn small" data-copy-text="${user.permanentId}">ã‚³ãƒ”ãƒ¼</button>
          </div>
          <div style="display:flex; align-items:center; gap:8px;">
            <span>Daily ID: ${user.id}</span>
            <button class="btn small" data-copy-text="${user.id}">ã‚³ãƒ”ãƒ¼</button>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>é€šçŸ¥è¨­å®š</h2>
        <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
            <input type="checkbox" id="soundToggleCheckbox" ${soundSettings.enabled ? 'checked' : ''}>
            <span>è‡ªåˆ†å®›ã¦ã®ãƒ¬ã‚¹ãŒã‚ã£ãŸæ™‚ã«é€šçŸ¥éŸ³ã‚’é³´ã‚‰ã™</span>
        </label>
      </div>

      <div class="card">
        <h2>åå‰å¤‰æ›´å±¥æ­´</h2>
        <div id="nameHistoryContainer" style="font-size:13px;"></div>
      </div>
      
      <div class="card">
        <h2>è‡ªåˆ†ã®æŠ•ç¨¿ã‚’æ¤œç´¢</h2>
        <div class="search-box">
          <input type="text" id="myPostSearchInput" placeholder="ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢">
          <button id="myPostSearchBtn" class="btn small">æ¤œç´¢</button>
        </div>
        <div id="myPostSearchResults"></div>
      </div>

      <div class="card">
        <h2>NGãƒ¯ãƒ¼ãƒ‰è¨­å®š</h2>
        <div style="display:flex; gap:8px; margin-bottom:12px;">
          <input type="text" id="ngWordInput" placeholder="NGãƒ¯ãƒ¼ãƒ‰" style="flex-grow:1;">
          <select id="ngActionSelect">
            <option value="hide">æŠ•ç¨¿ã‚’éè¡¨ç¤º</option>
            <option value="red">å˜èªã‚’èµ¤æ–‡å­—</option>
          </select>
          <button id="addNgWordBtn" class="btn small">è¿½åŠ </button>
        </div>
        <div id="ngWordsListContainer"></div>
      </div>
    `;

    document.getElementById('settingsSaveNameBtn').onclick = () => {
      const newName = document.getElementById('settingsNameInput').value.trim();
      if(newName && !containsNGWord(newName)) {
        if(setUserName(newName)) {
          alert('åå‰ã‚’å¤‰æ›´ã—ã¾ã—ãŸã€‚');
          renderSettingsPage();
        }
      } else {
        alert('åå‰ãŒç©ºã‹ã€ä¸é©åˆ‡ãªå˜èªãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚');
      }
    };
    
    document.querySelectorAll('[data-copy-text]').forEach(btn => {
      btn.onclick = (e) => {
        navigator.clipboard.writeText(e.target.dataset.copyText).then(() => {
          const originalText = e.target.textContent;
          e.target.textContent = 'OK!';
          setTimeout(() => { e.target.textContent = originalText; }, 1000);
        });
      };
    });

    document.getElementById('soundToggleCheckbox').onchange = (e) => {
        saveSoundSettings({ enabled: e.target.checked });
    };

    const nameHistoryContainer = document.getElementById('nameHistoryContainer');
    const nameHistory = loadNameHistory();
    if (nameHistory.length > 0) {
      nameHistoryContainer.innerHTML = nameHistory.map(h => 
        `<div><span class="small-muted">${formatTimestamp(h.changedAt)}</span> â†’ <b>${escapeHTML(h.name)}</b></div>`
      ).join('');
    } else {
      nameHistoryContainer.innerHTML = '<div class="small-muted">å¤‰æ›´å±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</div>';
    }

    document.getElementById('myPostSearchBtn').onclick = async () => {
      const keyword = document.getElementById('myPostSearchInput').value.trim();
      const resultsContainer = document.getElementById('myPostSearchResults');
      if (!keyword) {
        resultsContainer.innerHTML = '<div class="small-muted">ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚</div>';
        return;
      }
      startLoadingAnimation(resultsContainer, 'ã‚ãªãŸã®æŠ•ç¨¿ã‚’æ¤œç´¢ä¸­');
      
      try {
        const myId = getUser().permanentId;
        const userPostsRef = db.ref('userPosts/' + myId);
        const snapshot = await userPostsRef.once('value');
        const userPosts = snapshot.val() || {};

        const fetchPromises = Object.entries(userPosts).map(async ([postId, postInfo]) => {
            const postSnapshot = await db.ref(`threads/${postInfo.threadId}/posts/${postId}`).once('value');
            const postData = postSnapshot.val();
            if (postData && postData.text.toLowerCase().includes(keyword.toLowerCase())) {
                const threadMetaSnapshot = await db.ref(`threadMetadata/${postInfo.threadId}`).once('value');
                return { post: postData, thread: threadMetaSnapshot.val() };
            }
            return null;
        });
        
        const results = (await Promise.all(fetchPromises)).filter(Boolean);
        stopLoadingAnimation();

        if (results.length > 0) {
            resultsContainer.innerHTML = results.sort((a, b) => b.post.createdAt - a.post.createdAt).map(item => `
                <div style="border-top:1px solid var(--border-color); padding: 8px 0;">
                    <div class="small-muted">ã‚¹ãƒ¬: <a href="#thread-${item.thread.id}">${escapeHTML(item.thread.title)}</a> (${formatTimestamp(item.post.createdAt)})</div>
                    <div>${renderContent(item.post.text)}</div>
                </div>
            `).join('');
        } else {
            resultsContainer.innerHTML = `<div class="small-muted">ã€Œ${escapeHTML(keyword)}ã€ã«ä¸€è‡´ã™ã‚‹ã‚ãªãŸã®æŠ•ç¨¿ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚</div>`;
        }
      } catch (e) {
        stopLoadingAnimation();
        resultsContainer.innerHTML = `<div class="banned-note">æ¤œç´¢ã«å¤±æ•—ã—ã¾ã—ãŸ: ${e.message}</div>`;
        console.error(e);
      }
    };

    const ngWordInput = document.getElementById('ngWordInput');
    const ngActionSelect = document.getElementById('ngActionSelect');
    const addNgWordBtn = document.getElementById('addNgWordBtn');
    const ngWordsListContainer = document.getElementById('ngWordsListContainer');

    function renderNgList() {
      const settings = loadNgSettings();
      const words = Object.keys(settings);
      if (words.length > 0) {
        ngWordsListContainer.innerHTML = words.map(word => `
          <div style="display:flex; align-items:center; gap:8px; font-size:13px; padding: 4px 0;">
            <span style="flex-grow:1;"><b>${escapeHTML(word)}</b> â†’ <span class="small-muted">${settings[word] === 'hide' ? 'éè¡¨ç¤º' : 'èµ¤æ–‡å­—'}</span></span>
            <button class="btn small warn" data-ng-word="${escapeHTML(word)}">å‰Šé™¤</button>
          </div>
        `).join('');
        ngWordsListContainer.querySelectorAll('[data-ng-word]').forEach(btn => {
          btn.onclick = (e) => {
            const wordToDelete = e.target.dataset.ngWord;
            const currentSettings = loadNgSettings();
            delete currentSettings[wordToDelete];
            saveNgSettings(currentSettings);
            renderNgList();
          };
        });
      } else {
        ngWordsListContainer.innerHTML = '<div class="small-muted">NGãƒ¯ãƒ¼ãƒ‰ã¯è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</div>';
      }
    }
    
    addNgWordBtn.onclick = () => {
      const word = ngWordInput.value.trim();
      if (word) {
        const action = ngActionSelect.value;
        const settings = loadNgSettings();
        settings[word] = action;
        saveNgSettings(settings);
        ngWordInput.value = '';
        renderNgList();
      }
    };
    
    renderNgList();
  }
  
  function generatePostHtml(post, idx, t, userLevels, globalBanList, anchorCounts) {
    const u = getUser(), o = t.op && t.op.permanentId === u.permanentId, isAdm = ADMIN_IDS.includes(u.permanentId);
    
    const exp = (userLevels[post.author.permanentId] && userLevels[post.author.permanentId].exp) || 0;
    const l = getLevel(exp);
    
    const b=t.banned&&t.banned[post.author.permanentId],gb=globalBanList[post.author.permanentId];
    const reacs=post.reactions||{};
    const mR=reacs[u.permanentId];

    let aH=`<b class="post-author" data-action="show-profile" data-name="${escapeHTML(post.author.name)}" data-id="${post.author.permanentId}" data-daily-id="${post.author.id}" data-isopadm="${o||isAdm}">${escapeHTML(post.author.name)}</b> <span class="badge-level" title="Lv.${l.level}">${l.title}</span>`;
    if(post.author.permanentId===t.op.permanentId) aH+=` <span class="badge-op">ä¸»</span>`;
    if(anchorCounts[post.id]) { aH += ` <span class="badge-anchor" data-action="show-anchors" data-thread-id="${t.id}" data-post-id="${post.id}">${anchorCounts[post.id]}</span>`; }
    
    const rC={}; BASE_REACTIONS.forEach(r=>rC[r]=0);
    Object.values(reacs).forEach(reac=>{if(rC[reac]!==undefined)rC[reac]++;});
    
    let ctlH=BASE_REACTIONS.map(bR=>{
      const count=rC[bR];
      const iMR=mR===bR;
      const dR=iMR?REACTION_PAIRS[bR]:bR;
      return`<button class="btn small ${iMR?'liked':''}" data-action="react" data-thread-id="${t.id}" data-post-id="${post.id}" data-reac="${bR}">${dR} ${count}</button>`;
    }).join(' ');

    if(u.permanentId===post.author.permanentId||o||isAdm) ctlH+=` <button class="btn small warn" data-action="delete-post" data-thread-id="${t.id}" data-post-id="${post.id}">å‰Šé™¤</button>`;
    if(u.permanentId===post.author.permanentId) ctlH+=` <button class="btn small" data-action="edit-post" data-thread-id="${t.id}" data-post-id="${post.id}">ç·¨é›†</button>`;
    
    const ngSettings = loadNgSettings();
    const ngWords = Object.keys(ngSettings);
    let pB=post.deleted?`<div class="deleted-note">[å‰Šé™¤ã•ã‚Œã¾ã—ãŸ]</div>`:`<div class="body">${renderContent(post.text,post)}</div>${post.img?`<img src="${post.img}" class="post-image" data-action="open-lightbox">`:''}`;
    if (!post.deleted) {
      let isHidden = false;
      let processedText = renderContent(post.text, post);
      for (const word of ngWords) {
        if (post.text.toLowerCase().includes(word.toLowerCase())) {
          if (ngSettings[word] === 'hide') {
            pB = `<div class="ng-hidden-post">[NGãƒ¯ãƒ¼ãƒ‰ã«ä¸€è‡´ã—ãŸãŸã‚éè¡¨ç¤º]</div>`; isHidden = true; break; 
          } else if (ngSettings[word] === 'red') {
            const regex = new RegExp(escapeHTML(word), 'gi');
            processedText = processedText.replace(regex, `<span class="ng-word-red">${escapeHTML(word)}</span>`);
          }
        }
      }
      if (!isHidden) { pB = `<div class="body">${processedText}</div>${post.img?`<img src="${post.img}" class="post-image" data-action="open-lightbox">`:''}`; }
    }

    const mainContent = b||gb ? `<div class="banned-note">${gb?'[ã“ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯BANã•ã‚Œã¦ã„ã¾ã™]':'[ã“ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã“ã®ã‚¹ãƒ¬ã§ã‚¢ã‚¯ç¦ã•ã‚Œã¦ã„ã¾ã™]'}</div>` : `${pB}<div class="controls">${ctlH}<span class="timestamp small-muted">${formatTimestamp(post.createdAt)}</span></div>`;
    
    return `<div class="post" data-post-id="${post.id}"><div class="meta"><span class="no" data-action="insert-quote-number" data-num="${idx}">No.${idx}</span>${aH}</div>${mainContent}</div>`;
  }

  function fullRenderThreadView(id, t, userLevels, globalBanList) {
    const u = getUser(), o = t.op && t.op.permanentId === u.permanentId, isAdm = ADMIN_IDS.includes(u.permanentId);
    let deleteBtnHtml = (o || isAdm) ? `<button class="btn small warn" data-action="delete-thread" data-thread-id="${id}" style="margin-left:auto;">ã‚¹ãƒ¬ãƒƒãƒ‰å‰Šé™¤</button>` : '';
    
    const posts = Object.values(t.posts || {}).filter(p => p && typeof p === 'object').sort((a, b) => a.createdAt - b.createdAt);
    const pC = posts.length;

    let rF = '';
    if (pC >= POST_LIMIT) {
        rF = (o) ? `<div style="text-align:center; padding:10px;"><button class="btn" onclick="window.prepareNextThread('${id}')">æ¬¡ã‚¹ãƒ¬ã‚’ä½œæˆ</button></div>` : `<div class="banned-note" style="text-align:center;padding:10px;">ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯${POST_LIMIT}ãƒ¬ã‚¹ã«é”ã—ã¾ã—ãŸã€‚</div>`;
    } else {
        rF = `<h4>ãƒ¬ã‚¹æŠ•ç¨¿</h4><input id="replyName" type="text" placeholder="åå‰" value="${escapeHTML(u.name)}" style="margin-bottom:8px;"><small class="small-muted" style="display:block;margin-top:-6px;margin-bottom:8px;">åå‰æ¬„ã« sage ã¨å…¥åŠ›ã™ã‚‹ã¨ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒˆãƒƒãƒ—ã«ä¸ŠãŒã‚‰ãªããªã‚Šã¾ã™ã€‚</small><textarea id="replyText" placeholder="æœ¬æ–‡"></textarea><div class="controls" style="justify-content:flex-start; margin-top:8px;"><button id="createVoteBtn" class="btn small">ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆä½œæˆ</button></div><div style="margin-top:8px; display:flex; justify-content:space-between; align-items:center;"><input id="replyImage" type="file" accept="image/*"><button class="btn" id="replyBtn">æŠ•ç¨¿</button></div>`;
    }

    const anchorCounts = {};
    posts.forEach((p, postIndex) => {
        if (p.text) {
            const anchors = p.text.match(/>>(\d+)/g) || [];
            anchors.forEach(anchor => {
                const postNum = parseInt(anchor.replace('>>', ''), 10);
                if(postNum > 0 && postNum <= posts.length){
                    const targetPostId = posts[postNum - 1].id;
                    anchorCounts[targetPostId] = (anchorCounts[targetPostId] || 0) + 1;
                }
            });
        }
    });

    const postsHtml = posts.map((post, idx) => generatePostHtml(post, idx + 1, t, userLevels, globalBanList, anchorCounts)).join('');
    
    document.getElementById('app').innerHTML = `<div class="card"><div class="thread-header"><div class="thread-header-main"><h2>${escapeHTML(t.title)}</h2></div><div class="thread-header-meta"><div class="small-muted">ä½œæˆ: ${formatTimestamp(t.createdAt)}</div><div class="small-muted" style="margin-top:4px;">é–²è¦§ä¸­: <span id="viewer-count">${currentViewers}</span>äºº</div></div></div><div style="display:flex; justify-content:flex-end; margin-bottom:8px;">${deleteBtnHtml}</div><div class="search-box" style="padding: 12px; background: var(--bg); border-radius: 8px; margin-bottom: 12px;"><input type="text" id="threadSearchInput" placeholder="ã“ã®ã‚¹ãƒ¬å†…ã‚’æ¤œç´¢"><button id="threadSearchBtn" class="btn small">æ¤œç´¢</button><button id="threadSearchClearBtn" class="btn small">ã‚¯ãƒªã‚¢</button></div></div><div class="card" id="postsContainer">${postsHtml}</div><div class="card">${rF}</div>`;

    if (pC < POST_LIMIT) {
        document.getElementById('replyBtn').onclick = () => postReply(id);
        setupVoteModal('replyText');
    }
    
    const searchInput = document.getElementById('threadSearchInput');
    const searchBtn = document.getElementById('threadSearchBtn');
    const clearBtn = document.getElementById('threadSearchClearBtn');

    const updateHighlighting = (keyword) => {
        const posts = document.querySelectorAll('#postsContainer .post');
        posts.forEach(post => {
            const body = post.querySelector('.body');
            if (!body) return;

            const highlightedSpans = body.querySelectorAll('span.search-highlight');
            highlightedSpans.forEach(span => {
                span.replaceWith(...span.childNodes);
            });
            body.normalize(); 
            
            if (keyword && keyword.trim() !== '') {
                try {
                  const regex = new RegExp(escapeHTML(keyword.trim()).replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                  const newHtml = body.innerHTML.replace(regex, `<span class="search-highlight">$&</span>`);
                  if (newHtml !== body.innerHTML) {
                    body.innerHTML = newHtml;
                  }
                } catch(e) { /* Invalid regex */ }
            }
        });
    };

    const performSearch = () => {
        const keyword = searchInput.value.trim();
        updateHighlighting(keyword);
        const posts = document.querySelectorAll('#postsContainer .post');
        
        posts.forEach(post => {
            const body = post.querySelector('.body');
            if (!body) return;

            const text = body.textContent.toLowerCase();
            if (keyword === '' || text.includes(keyword.toLowerCase())) {
                post.style.display = 'block';
            } else {
                post.style.display = 'none';
            }
        });
    };

    searchBtn.onclick = performSearch;
    searchInput.onkeydown = (e) => {
        if (e.key === 'Enter') {
            performSearch();
        }
    };
    clearBtn.onclick = () => {
        searchInput.value = '';
        performSearch();
    };
  }

  function updateThreadViewSmart(id, t, userLevels, globalBanList) {
    if (!t) { removeFromHistory(id); goHome(); return; }

    const postsContainer = document.getElementById('postsContainer');
    if (!postsContainer) return;
    
    const u = getUser();
    const newPosts = Object.values(t.posts || {}).filter(p => p && typeof p === 'object').sort((a, b) => a.createdAt - b.createdAt);
    
    const anchorCounts = {};
    newPosts.forEach((p, postIndex) => {
        if (p.text) {
            const anchors = p.text.match(/>>(\d+)/g) || [];
            anchors.forEach(anchor => {
                const postNum = parseInt(anchor.replace('>>', ''), 10);
                if(postNum > 0 && postNum <= newPosts.length){
                    const targetPostId = newPosts[postNum - 1].id;
                    anchorCounts[targetPostId] = (anchorCounts[targetPostId] || 0) + 1;
                }
            });
        }
    });

    const existingPostElements = postsContainer.querySelectorAll('.post');
    if (newPosts.length > existingPostElements.length) {
      for (let i = existingPostElements.length; i < newPosts.length; i++) {
        const postHtml = generatePostHtml(newPosts[i], i + 1, t, userLevels, globalBanList, anchorCounts);
        postsContainer.insertAdjacentHTML('beforeend', postHtml);
      }
    }

    newPosts.forEach((post, idx) => {
        const postElement = postsContainer.querySelector(`[data-post-id="${post.id}"]`);
        if (!postElement) return;

        if (currentEditState && post.id === currentEditState.postId) {
            const reacs = post.reactions || {};
            const reactionButtons = postElement.querySelectorAll('[data-action="react"]');
            
             reactionButtons.forEach(btn => {
                const reacType = btn.dataset.reac;
                let count = 0;
                Object.values(reacs).forEach(r => { if (r === reacType) count++; });
                const isMyReaction = reacs[u.permanentId] === reacType;
                const displayEmoji = isMyReaction ? REACTION_PAIRS[reacType] : reacType;
                
                btn.textContent = `${displayEmoji} ${count}`;
                btn.classList.toggle('liked', isMyReaction);
            });
            return; 
        }

        const newPostHtml = generatePostHtml(post, idx + 1, t, userLevels, globalBanList, anchorCounts);
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = newPostHtml;

        if (tempDiv.firstChild && postElement.innerHTML !== tempDiv.firstChild.innerHTML) {
          postElement.replaceWith(tempDiv.firstChild);
        }
    });
  }

  async function renderThread(id) {
    document.getElementById('app').innerHTML=`<div class="card" id="loading-container"></div>`;
    startLoadingAnimation(document.getElementById('loading-container'));
    
    const newThreadPackageJSON = sessionStorage.getItem('new_thread_package');
    if (newThreadPackageJSON) {
        sessionStorage.removeItem('new_thread_package');
        const { threadData, userLevels } = JSON.parse(newThreadPackageJSON);
        userLevelsCache = userLevels;
        stopLoadingAnimation();
        fullRenderThreadView(id, threadData, userLevels, globalBanList);
        // ãƒªã‚¹ãƒŠãƒ¼è¨­å®šãªã©ã¯ã“ã“ã§ã‚‚å¿…è¦
    } else {
      try {
          const [threadSnapshot, userLevelsSnapshot] = await Promise.all([
              db.ref('threads/' + id).once('value'),
              db.ref('userLevels').once('value')
          ]);

          const threadData = threadSnapshot.val();
          const userLevels = userLevelsSnapshot.val() || {};
          userLevelsCache = userLevels; 
          
          if (!threadData) {
              stopLoadingAnimation();
              document.getElementById('app').innerHTML = `<div class="card"><div class="banned-note">è²´æ–¹ãŒæ¢ã—ã¦ã„ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ãƒ¬ãƒ¼ãƒ†ã®å¥”æµã«é‚„ã‚Šã¾ã—ãŸâ€¦</div></div>`;
              removeFromHistory(id);
              return;
          }

          myTotalExp = (userLevels[getUser().permanentId] && userLevels[getUser().permanentId].exp) || 0;
          
          if(threadData.levelRestriction > 0) {
              if (getLevel(myTotalExp).level < threadData.levelRestriction) {
                  stopLoadingAnimation();
                  document.getElementById('app').innerHTML = `<div class="card"><div class="banned-note">ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é–²è¦§ãƒ»æŠ•ç¨¿ã™ã‚‹ã«ã¯ Lv.${threadData.levelRestriction} ä»¥ä¸ŠãŒå¿…è¦ã§ã™ã€‚</div></div>`;
                  return;
              }
          }
          
          if (unreadStatus[id]) {
              unreadStatus[id] = 0;
              updateTotalUnreadBadge();
          }
          addToHistory(id, threadData.title, threadData.lastUpdatedAt);

          stopLoadingAnimation();
          fullRenderThreadView(id, threadData, userLevels, globalBanList);
      } catch(e) {
          stopLoadingAnimation();
          console.error(e);
          document.getElementById('app').innerHTML = `<div class="card"><div class="banned-note">ã‚¹ãƒ¬ãƒƒãƒ‰ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</div></div>`;
          return;
      }
    }

    // å…±é€šã®ãƒªã‚¹ãƒŠãƒ¼è¨­å®š
    const vRef=db.ref('viewers/'+id);
    myConnectionRef=vRef.push(true);
    myConnectionRef.onDisconnect().remove();
    const vCb=vRef.on('value',s=>{
        const count = s.numChildren();
        currentViewers = count;
        db.ref('threadMetadata/' + id + '/viewerCount').set(count);
        const e = document.getElementById('viewer-count');
        if(e) e.textContent = currentViewers;
    });
    activeViewersListener={ref:vRef,callback:vCb};

    const threadRef = db.ref('threads/'+id);
    const cb = threadRef.on('value', async (s) => {
        const currentData = s.val();
        if (currentData) {
            const updatedUserLevelsSnapshot = await db.ref('userLevels').once('value');
            const updatedUserLevels = updatedUserLevelsSnapshot.val() || {};
            userLevelsCache = updatedUserLevels; 
            updateThreadViewSmart(id, currentData, updatedUserLevels, globalBanList);
        } else {
            updateThreadViewSmart(id, null, {}, globalBanList);
        }
    }, e => { console.error(e); document.getElementById('app').innerHTML = `<div class="card"><div class="banned-note">ã‚¹ãƒ¬ãƒƒãƒ‰ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</div></div>`;});
    activeDataListener={ref:threadRef,callback:cb};
  }

  function processDiceCommands(text) {
    const diceRegex = /!dice(\s+(\d+)d(\d+))?/gi;
    return text.replace(diceRegex, (match, details, countStr, facesStr) => {
        let count, faces;
        
        if (details) {
            count = parseInt(countStr, 10) || 1;
            faces = parseInt(facesStr, 10) || 100;
        } else {
            count = 1;
            faces = 100;
        }
        
        count = Math.max(1, Math.min(count, 20)); 
        faces = Math.max(1, Math.min(faces, 10000));

        const rolls = [];
        let sum = 0;
        for (let i = 0; i < count; i++) {
            const roll = Math.floor(Math.random() * faces) + 1;
            rolls.push(roll);
            sum += roll;
        }
        
        const rollsStr = rolls.join(', ');
        return `[${count}D${faces}=${sum} (${rollsStr})]`;
    });
  }

  async function postReply(id) {
    const b=document.getElementById('replyBtn');b.disabled=true;
    try {
        const threadSnapshot = await db.ref(`threads/${id}`).once('value');
        const threadData = threadSnapshot.val();
        if (!threadData) throw new Error('ã‚¹ãƒ¬ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
        
        const isLevelUpThread = threadData.tags && threadData.tags.includes('ãƒ¬ãƒ™ãƒ«ä¸Šã’');

        if (!isLevelUpThread) {
            const lastPostTime=localStorage.getItem(LAST_POST_TIME_KEY);
            if(lastPostTime&&Date.now()-parseInt(lastPostTime)<POST_INTERVAL_SECONDS*1000){throw new Error(`æŠ•ç¨¿ã¯${POST_INTERVAL_SECONDS}ç§’ã«1å›ã¾ã§ã§ã™ã€‚`);}
        }

        const u=getUser();
        const iGB=(await db.ref(`globalBan/${u.permanentId}`).once('value')).val();if(iGB)throw new Error('ã‚ãªãŸã¯ã“ã®æ²ç¤ºæ¿ã‹ã‚‰è¿½æ”¾ã•ã‚Œã¦ã„ã¾ã™ã€‚');
        
        if(threadData.postCounter >= POST_LIMIT) throw new Error(`ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯${POST_LIMIT}ãƒ¬ã‚¹ã®ä¸Šé™ã«é”ã—ã¾ã—ãŸã€‚`);

        const cU=getUser();const nN=document.getElementById('replyName').value.trim();const iS=nN.toLowerCase()==='sage';const fN=iS?cU.name:(nN||cU.name);
    
        let rawText = document.getElementById('replyText').value;
        
        rawText = processDiceCommands(rawText);
    
        const t = rawText.trim();
    
        if(t.length > TEXT_LIMIT) throw new Error(`æœ¬æ–‡ã¯${TEXT_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
        if((rawText.match(/\n/g) || []).length > MAX_NEWLINES) throw new Error(`æ”¹è¡Œã¯${MAX_NEWLINES}å›ã¾ã§ã§ã™ã€‚`);
        if(rawText.match(new RegExp(`\\n{${MAX_CONSECUTIVE_NEWLINES + 1},}`))) throw new Error(`é€£ç¶šã—ãŸæ”¹è¡Œã¯${MAX_CONSECUTIVE_NEWLINES}å›ã¾ã§ã§ã™ã€‚`);
        if(fN.length>NAME_LIMIT)throw new Error(`åå‰ã¯${NAME_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
        if(fN&&fN!==cU.name){if(!setUserName(fN))throw new Error(`åå‰ã¯${NAME_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);}
        if(containsNGWord(t)||containsNGWord(fN))throw new Error('ä¸é©åˆ‡ãªå˜èªãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚');
        const f=document.getElementById('replyImage').files[0];if(!t&&!f)throw new Error('æœ¬æ–‡ã‹ç”»åƒãŒå¿…è¦ã§ã™');
        
        if(threadData.banned && threadData.banned[cU.permanentId]) throw new Error('ã‚ãªãŸã¯ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã‚¢ã‚¯ç¦ã•ã‚Œã¦ã„ã¾ã™ã€‚');

        const i=f?await readFileAsDataURL(f):null;
        const nPR=db.ref(`threads/${id}/posts`).push();
        const nPK=nPR.key;
        const now = Date.now();
        const pD={id:nPK,author:cU,text:t,img:i,createdAt:now};
        
        const upd={};
        upd[`threads/${id}/posts/${nPK}`]=pD;
        upd[`threads/${id}/postCounter`]=firebase.database.ServerValue.increment(1);
        upd[`threadMetadata/${id}/postCounter`]=firebase.database.ServerValue.increment(1); 
        upd[`/userPosts/${cU.permanentId}/${nPK}`] = { threadId: id, createdAt: now };
        
        if(!iS && !isLevelUpThread){
            const timestamp = firebase.database.ServerValue.TIMESTAMP;
            upd[`threads/${id}/lastUpdatedAt`]=timestamp;
            upd[`threadMetadata/${id}/lastUpdatedAt`]=timestamp;
        }
        
        let currentActivity = loadDailyActivity();
        const todayStr = getJstDateString();
        
        if (todayStr !== currentActivity.date) {
            currentActivity = { date: todayStr, postCount: 1 };
        } else {
            currentActivity.postCount++;
        }
        saveDailyActivity(currentActivity);

        await db.ref().update(upd);
        
        localStorage.setItem(LAST_POST_TIME_KEY,Date.now().toString());
        document.getElementById('replyText').value='';
        document.getElementById('replyImage').value='';
    }catch(e){
        alert('æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼: '+e.message);
    }finally{
        if(b) b.disabled=false;
    }
  }
  
  function containsNGWord(t){const l=t.toLowerCase();return NG_WORDS.some(w=>l.includes(w.toLowerCase()));}
  function processImage(file) {
      return new Promise((resolve, reject) => {
          if (!file.type.startsWith('image/')) reject(new Error('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„'));
          if (file.size > MAX_IMAGE_BYTES) reject(new Error(`ç”»åƒã‚µã‚¤ã‚ºã¯${MAX_IMAGE_BYTES / 1024 / 1024}MBä»¥ä¸‹ã«ã—ã¦ãã ã•ã„`));

          const reader = new FileReader();
          reader.onload = (e) => {
              const fullDataURL = e.target.result;
              const img = new Image();
              img.onload = () => {
                  const canvas = document.createElement('canvas');
                  const ctx = canvas.getContext('2d');
                  canvas.width = THUMBNAIL_WIDTH;
                  canvas.height = THUMBNAIL_HEIGHT;

                  const aspect = img.width / img.height;
                  let sx, sy, sw, sh;
                  if (aspect > 1) { // æ¨ªé•·
                      sh = img.height;
                      sw = sh;
                      sx = (img.width - sw) / 2;
                      sy = 0;
                  } else { // ç¸¦é•· or æ­£æ–¹å½¢
                      sw = img.width;
                      sh = sw;
                      sy = (img.height - sh) / 2;
                      sx = 0;
                  }
                  ctx.drawImage(img, sx, sy, sw, sh, 0, 0, THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT);
                  const thumbDataURL = canvas.toDataURL('image/jpeg', THUMBNAIL_QUALITY);
                  resolve({ full: fullDataURL, thumb: thumbDataURL });
              };
              img.onerror = reject;
              img.src = fullDataURL;
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
      });
  }
  async function readFileAsDataURL(f){if(!f.type.startsWith('image/'))throw new Error('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');if(f.size>MAX_IMAGE_BYTES)throw new Error(`ç”»åƒã‚µã‚¤ã‚ºã¯${MAX_IMAGE_BYTES/1024/1024}MBä»¥ä¸‹ã«ã—ã¦ãã ã•ã„`);return new Promise((s,j)=>{const r=new FileReader();r.onload=()=>s(r.result);r.onerror=j;r.readAsDataURL(f);});}

  function setupVoteModal(textareaId){const oB=document.getElementById('createVoteBtn');if(!oB)return;const m=document.getElementById('voteModal'),cM=document.getElementById('closeVoteModalBtn'),aO=document.getElementById('addVoteOptionBtn'),iB=document.getElementById('insertVoteBtn'),con=document.getElementById('voteOptionsContainer'),dS=document.getElementById('voteDeadlineSelect');oB.onclick=()=>{m.style.display='flex';};cM.onclick=()=>{m.style.display='none';};m.onclick=(e)=>{if(e.target===e.currentTarget)m.style.display='none';};aO.onclick=()=>{const i=document.createElement('input');i.type='text';i.className='vote-option-input';i.placeholder=`é¸æŠè‚¢${con.children.length+1}`;i.style.marginBottom='8px';con.appendChild(i);};iB.onclick=()=>{const optsRaw=Array.from(con.getElementsByClassName('vote-option-input')).map(i=>i.value.trim());const opts=optsRaw.filter(v=>v!=='');if(opts.length<2){alert('æœ‰åŠ¹ãªé¸æŠè‚¢ã‚’2ã¤ä»¥ä¸Šå…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');return;}const uniqueOpts=[...new Set(opts)];if(uniqueOpts.length!==opts.length){alert('é¸æŠè‚¢ãŒé‡è¤‡ã—ã¦ã„ã¾ã™ã€‚');return;}for(const opt of uniqueOpts){if(opt.length>VOTE_OPTION_LIMIT){alert(`é¸æŠè‚¢ã¯${VOTE_OPTION_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);return;}}const deadlineDuration=parseInt(dS.value,10);const deadlineTimestamp=deadlineDuration>0?Date.now()+deadlineDuration:0;const tag=`[vote(${deadlineTimestamp}):${uniqueOpts.join(',')}]`;const ta=document.getElementById(textareaId);ta.value+=`\n${tag}\n`;m.style.display='none';};}
  
  window.react = (t, p, reac) => {const r=db.ref(`threads/${t}/posts/${p}/reactions`),u=getUser().permanentId;r.transaction(c=>{if(c===null)c={};if(c[u]===reac){delete c[u];}else{c[u]=reac;}return Object.keys(c).length>0?c:null;});};
  
  function exitEditMode(options = {}) {
      if (!currentEditState) return;
      const { postElement, originalControlsHTML, originalBodyHTML } = currentEditState;
  
      const bodyContainer = postElement.querySelector('.body-container');
      const controls = postElement.querySelector('.controls');
  
      if (options.postWasDeleted) {
          postElement.children[1].innerHTML = '<div class="deleted-note">[å‰Šé™¤ã•ã‚Œã¾ã—ãŸ]</div>';
      } else {
          const newBody = document.createElement('div');
          newBody.className = 'body';
          
          if (options.newText) {
              newBody.innerHTML = renderContent(options.newText);
          } else {
              newBody.innerHTML = originalBodyHTML;
          }
          
          if (bodyContainer) {
              bodyContainer.replaceWith(newBody);
          }
          
          if (controls) {
              controls.innerHTML = originalControlsHTML;
          }
      }
      currentEditState = null;
  }

  window.editPost = async (threadId, postId) => {
      if (currentEditState) {
          exitEditMode();
      }

      const postRef = db.ref(`threads/${threadId}/posts/${postId}`);
      const snapshot = await postRef.once('value');
      const originalPost = snapshot.val();

      if (!originalPost || originalPost.author.permanentId !== getUser().permanentId) {
          alert('è‡ªåˆ†ã®æŠ•ç¨¿ã—ã‹ç·¨é›†ã§ãã¾ã›ã‚“');
          return;
      }

      const postElement = document.querySelector(`[data-post-id="${postId}"]`);
      if (!postElement) return;

      const bodyElement = postElement.querySelector('.body');
      const controlsElement = postElement.querySelector('.controls');
      
      const bodyContainer = document.createElement('div');
      bodyContainer.className = 'body-container';
      bodyElement.replaceWith(bodyContainer);

      const originalBodyHTML = renderContent(originalPost.text, originalPost);
      const originalControlsHTML = controlsElement.innerHTML;

      currentEditState = { postId, threadId, postElement, originalBodyHTML, originalControlsHTML };
      
      const textarea = document.createElement('textarea');
      textarea.value = originalPost.text;
      textarea.style.cssText = 'width: 100%; min-height: 120px; resize: vertical; margin-top: 8px;';
      bodyContainer.innerHTML = '';
      bodyContainer.appendChild(textarea);
      textarea.focus();

      controlsElement.innerHTML = '';
      const saveBtn = document.createElement('button');
      saveBtn.className = 'btn small';
      saveBtn.textContent = 'ä¿å­˜';
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'btn small warn';
      cancelBtn.textContent = 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«';
      
      controlsElement.appendChild(cancelBtn);
      controlsElement.appendChild(saveBtn);
      
      saveBtn.onclick = async () => {
          let newText = textarea.value;
          
          if (newText.trim() === '') return alert('æœ¬æ–‡ã‚’ç©ºã«ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚');
          if (newText.length > TEXT_LIMIT) return alert(`æœ¬æ–‡ã¯${TEXT_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
          if (containsNGWord(newText)) return alert('ä¸é©åˆ‡ãªå˜èªãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚');

          newText = processDiceCommands(newText);
          saveBtn.disabled = true;
          saveBtn.textContent = 'ä¿å­˜ä¸­...';

          try {
              await postRef.update({ text: newText });
              exitEditMode({ newText: newText });
          } catch (e) {
              alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e.message);
              exitEditMode();
          }
      };

      cancelBtn.onclick = () => {
          exitEditMode();
      };
  };
  
  window.deletePost = (t, p) => {
    if (confirm('ã“ã®æŠ•ç¨¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
        const updates = {};
        updates[`threads/${t}/posts/${p}/deleted`] = true;
        updates[`threads/${t}/posts/${p}/text`] = '';
        updates[`threads/${t}/posts/${p}/img`] = null;
        updates[`userPosts/${getUser().permanentId}/${p}`] = null;
        db.ref().update(updates);
    }
  };
  
  window.toggleGlobalBan = async (userPermanentId, name) => {
    const btn = event.target;
    btn.disabled = true;
    try {
      const ref = db.ref(`globalBan/${userPermanentId}`);
      const snapshot = await ref.once('value');
      const isBanned = snapshot.val();
      const actionText = isBanned ? 'æ°¸ä¹…è¿½æ”¾ã‚’è§£é™¤' : 'æ°¸ä¹…è¿½æ”¾';
      if (confirm(`${name} ã‚’ ${actionText} ã—ã¾ã™ã‹ï¼Ÿ`)) {
        await ref.set(isBanned ? null : true);
        alert(`${name} ã®${actionText}ã«æˆåŠŸã—ã¾ã—ãŸã€‚`);
      }
    } catch (e) {
      alert("æ°¸ä¹…è¿½æ”¾ã«å¤±æ•—ã—ã¾ã—ãŸ");
      console.error(e);
    } finally {
      btn.disabled = false;
    }
  };

  window.showUserProfile = async (name, userPermanentId, dailyId, isOpAdm) => {
    const modal = document.getElementById('profileModal'), nameEl = document.getElementById('profileName'), idEl = document.getElementById('profileId'), postsListEl = document.getElementById('profilePostsList'), controlsEl = document.getElementById('profileControls');
    nameEl.textContent = name;
    idEl.textContent = `ID: ${dailyId}`;
    controlsEl.innerHTML = '';
    startLoadingAnimation(postsListEl, 'æŠ•ç¨¿å±¥æ­´ã‚’èª¿æŸ»ä¸­');
    modal.style.display = 'flex';

    try {
        const userPostsRef = db.ref('userPosts/' + userPermanentId).orderByChild('createdAt').limitToLast(100);
        const snapshot = await userPostsRef.once('value');
        const userPostsData = snapshot.val() || {};
        
        const postEntries = Object.entries(userPostsData).sort((a, b) => b[1].createdAt - a[1].createdAt);

        if (postEntries.length === 0) {
            throw new Error("No posts in index, falling back to full scan.");
        }

        const fetchPromises = postEntries.map(async ([postId, postInfo]) => {
            if (!postInfo || !postInfo.threadId) return null;
            const [postSnapshot, threadMetaSnapshot] = await Promise.all([
                db.ref(`threads/${postInfo.threadId}/posts/${postId}`).once('value'),
                db.ref(`threadMetadata/${postInfo.threadId}`).once('value')
            ]);
            const postData = postSnapshot.val();
            const threadData = threadMetaSnapshot.val();
            return (postData && threadData) ? { post: postData, thread: threadData } : null;
        });
        let results = (await Promise.all(fetchPromises)).filter(Boolean);
        
        if (results.length === 0) {
            throw new Error("Indexed posts were not found, falling back to full scan.");
        }
        
        stopLoadingAnimation();
        postsListEl.innerHTML = results.map(item => `
            <div class="profile-post-item" style="border-bottom: 1px solid var(--border-color); padding: 8px 0;">
                <div class="small-muted">ã‚¹ãƒ¬: <a href="#thread-${item.thread.id}" onclick="window.closeUserProfile()">${escapeHTML(item.thread.title)}</a></div>
                <div style="margin: 4px 0;">${item.post.deleted?'[å‰Šé™¤ã•ã‚Œã¾ã—ãŸ]':renderContent(item.post.text.substring(0,100))}${!item.post.deleted&&item.post.text.length>100?'...':''}</div>
                <button class="btn small" onclick="window.goToPost('${item.thread.id}','${item.post.id}')">æŠ•ç¨¿ã«é£›ã¶</button>
            </div>`).join('');

    } catch(e) {
        const worker = new Worker('search-worker.js');
        worker.postMessage({ command: 'initialize', firebaseConfig: firebaseConfig });
        worker.onmessage = (e) => {
            const { status, message, progress, results } = e.data;
            if (status === 'initialized') {
                db.ref('threadMetadata').orderByChild('lastUpdatedAt').once('value', snapshot => {
                    const allThreadsMeta = snapshot.val() ? Object.values(snapshot.val()).reverse() : [];
                    worker.postMessage({ command: 'search', allThreadsMeta: allThreadsMeta, userId: userPermanentId, keyword: null });
                });
            } else if (status === 'progress') {
                postsListEl.querySelector('span').textContent = `æŠ•ç¨¿å±¥æ­´ã‚’èª¿æŸ»ä¸­(ãƒ•ãƒ«ã‚¹ã‚­ãƒ£ãƒ³)â€¦ ${progress}%`;
            } else if (status === 'complete') {
                stopLoadingAnimation();
                if (results.length === 0) {
                  postsListEl.innerHTML = '<div class="small-muted">ã“ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æŠ•ç¨¿ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</div>';
                } else {
                  postsListEl.innerHTML = results.sort((a,b)=>b.post.createdAt-a.post.createdAt).map(item=>`<div class="profile-post-item" style="border-bottom: 1px solid var(--border-color); padding: 8px 0;"><div class="small-muted">ã‚¹ãƒ¬: <a href="#thread-${item.thread.id}" onclick="window.closeUserProfile()">${escapeHTML(item.thread.title)}</a></div><div style="margin: 4px 0;">${item.post.deleted?'[å‰Šé™¤ã•ã‚Œã¾ã—ãŸ]':renderContent(item.post.text.substring(0,100))}${!item.post.deleted&&item.post.text.length>100?'...':''}</div><button class="btn small" onclick="window.goToPost('${item.thread.id}','${item.post.id}')">æŠ•ç¨¿ã«é£›ã¶</button></div>`).join('');
                }
                worker.terminate();
            } else if (status === 'error') {
                stopLoadingAnimation();
                postsListEl.innerHTML = `<div class="banned-note">æŠ•ç¨¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${message}</div>`;
                worker.terminate();
            }
        };
    }
  };
  
  window.prepareNextThread = async (threadId) => {
    try {
        const snapshot = await db.ref(`threads/${threadId}`).once('value');
        const thread = snapshot.val();
        if (!thread) return;

        let newTitle = thread.title;
        const partMatch = thread.title.match(/Part\.(\d+)/);
        if (partMatch) {
            const nextPart = parseInt(partMatch[1]) + 1;
            newTitle = thread.title.replace(/Part\.\d+/, `Part.${nextPart}`);
        } else {
            newTitle = `${thread.title} Part.2`;
        }
        
        const newText = `å‰ã‚¹ãƒ¬ï¼š${location.origin}${location.pathname}#thread-${thread.id}\n\n`;

        localStorage.setItem(NEXT_THREAD_DATA_KEY, JSON.stringify({ title: newTitle, text: newText }));
        goHome();
    } catch(e) {
        alert('æ¬¡ã‚¹ãƒ¬ã®æº–å‚™ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        console.error(e);
    }
  };
  
  window.showAnchors = async (targetPostId, threadId) => {
      const modal = document.getElementById('anchorModal');
      const body = document.getElementById('anchorModalBody');
      startLoadingAnimation(body);
      modal.style.display = 'flex';

      try {
          const threadSnapshot = await db.ref(`threads/${threadId}`).once('value');
          const thread = threadSnapshot.val();
          if (!thread || !thread.posts) {
              stopLoadingAnimation();
              body.innerHTML = 'ã‚¨ãƒ©ãƒ¼: ã‚¹ãƒ¬ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚';
              return;
          }
          const allPosts = Object.values(thread.posts).sort((a, b) => a.createdAt - b.createdAt);
          const targetPostIndex = allPosts.findIndex(p => p.id === targetPostId) + 1;

          const anchorPosts = allPosts.filter(p => {
              if (!p.text) return false;
              const anchors = p.text.match(/>>(\d+)/g) || [];
              return anchors.some(anchor => parseInt(anchor.replace('>>', '')) === targetPostIndex);
          });

          stopLoadingAnimation();
          if (anchorPosts.length > 0) {
              body.innerHTML = anchorPosts.map(post => {
                  const author = post.author ? escapeHTML(post.author.name) : 'ä¸æ˜';
                  return `<div class="post"><div class="meta"><b class="post-author">${author}</b> <span class="small-muted">${formatTimestamp(post.createdAt)}</span></div><div class="body">${renderContent(post.text)}</div></div>`;
              }).join('');
          } else {
              body.innerHTML = '<div class="small-muted">ã“ã®æŠ•ç¨¿ã¸ã®è¿”ä¿¡ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</div>';
          }
      } catch(e) {
          stopLoadingAnimation();
          body.innerHTML = '<div class="banned-note">è¿”ä¿¡ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</div>';
          console.error(e);
      }
  };

  window.closeUserProfile=()=>{document.getElementById('profileModal').style.display='none';};
  window.goToPost=(t,p)=>{window.closeUserProfile();location.hash='thread-'+t;setTimeout(()=>{const postElement = document.querySelector(`[data-post-id="${p}"]`);if(postElement){postElement.scrollIntoView({behavior:'smooth',block:'center'});postElement.style.transition='background-color 0.5s';postElement.style.backgroundColor='rgba(21,101,192,0.1)';setTimeout(()=>{postElement.style.backgroundColor='';},2000);}},500);};
  
  function applyTheme(t){const b=document.getElementById('themeToggleBtn');if(t==='dark'){document.body.classList.add('dark-mode');if(b)b.textContent='â˜€ï¸';}else{document.body.classList.remove('dark-mode');if(b)b.textContent='ğŸŒ™';}}

  async function awardDailyBonusIfNeeded() {
    const user = getUser();
    let activity = loadDailyActivity();
    const todayStr = getJstDateString();

    if (todayStr !== activity.date && activity.postCount > 0) {
        const bonus = Math.floor(activity.postCount / 2);
        if (bonus > 0) {
            await db.ref(`userLevels/${user.permanentId}/exp`).transaction(currentExp => {
                return (currentExp || 0) + bonus;
            });
        }
        activity = { date: todayStr, postCount: 0 };
        saveDailyActivity(activity);
    }
  }

  async function getMyPostNumbersInThread(threadId, myId) {
    if (myPostNumbersCache[threadId]) return myPostNumbersCache[threadId];
    
    const snapshot = await db.ref(`threads/${threadId}/posts`).once('value');
    const threadPosts = snapshot.val() || {};
    threadDataCache[threadId] = threadPosts;

    const sortedPosts = Object.values(threadPosts).sort((a, b) => a.createdAt - b.createdAt);
    const myPostNumbers = new Set();
    sortedPosts.forEach((post, index) => {
        if (post && post.author && post.author.permanentId === myId) {
            myPostNumbers.add(index + 1);
        }
    });
    myPostNumbersCache[threadId] = myPostNumbers;
    return myPostNumbers;
  }

  function updateTotalUnreadBadge() {
    const badge = document.getElementById('historyUnreadBadge');
    if (!badge) return;
    const totalUnread = Object.values(unreadStatus).reduce((sum, count) => sum + count, 0);

    if (totalUnread > 0) {
        badge.textContent = totalUnread > 9 ? '9+' : totalUnread;
        badge.style.display = 'inline-flex';
    } else {
        badge.style.display = 'none';
    }
  }

  async function setupUnreadListeners() {
    activeUnreadListeners.forEach(l => { l.ref.off(l.type, l.callback); });
    activeUnreadListeners = [];
    unreadStatus = {};
    repliesToMe = {};
    updateTotalUnreadBadge();

    const history = loadHistory();
    const myId = getUser().permanentId;

    for (const item of history) {
      unreadStatus[item.id] = 0;
      repliesToMe[item.id] = new Set();
      const myPostNumbers = await getMyPostNumbersInThread(item.id, myId);

      if (myPostNumbers.size > 0) {
          const postsRef = db.ref('threads/' + item.id + '/posts');
          
          const addQuery = postsRef.orderByChild('createdAt').startAt(item.visitedAt + 1);
          
          const addCallback = addQuery.on('child_added', snapshot => {
              const newPost = snapshot.val();
              if (!newPost || !newPost.text || (newPost.author && newPost.author.permanentId === myId)) return;
              
              const anchors = newPost.text.match(/>>(\d+)/g) || [];
              if (anchors.some(anchor => myPostNumbers.has(parseInt(anchor.replace('>>', ''))))) {
                  unreadStatus[item.id] = (unreadStatus[item.id] || 0) + 1;
                  repliesToMe[item.id].add(newPost.id); 
                  updateTotalUnreadBadge();
                  
                  const soundSettings = loadSoundSettings();
                  if (soundSettings.enabled) {
                      const sound = document.getElementById('notificationSound');
                      sound.currentTime = 0;
                      sound.play().catch(e => { /* Autoplay was prevented */ });
                  }

                  if (location.hash === '#history') {
                      const container = document.getElementById(`unread-container-${item.id}`);
                      const badge = document.getElementById(`unread-badge-${item.id}`);
                      if (container && badge) {
                          badge.textContent = `ã‚ãªãŸã¸ã®æ–°ç€ãƒ¬ã‚¹: ${unreadStatus[item.id]}ä»¶`;
                          container.style.display = 'block';
                      }
                  }
              }
          });
          activeUnreadListeners.push({ ref: addQuery, type: 'child_added', callback: addCallback });

          const changeCallback = postsRef.on('child_changed', snapshot => {
              const changedPost = snapshot.val();
              if (changedPost && changedPost.deleted && repliesToMe[item.id].has(changedPost.id)) {
                  unreadStatus[item.id] = Math.max(0, (unreadStatus[item.id] || 0) - 1);
                  repliesToMe[item.id].delete(changedPost.id); 
                  updateTotalUnreadBadge();
                  if (location.hash === '#history') {
                      const container = document.getElementById(`unread-container-${item.id}`);
                      const badge = document.getElementById(`unread-badge-${item.id}`);
                      if (container && badge) {
                          if(unreadStatus[item.id] > 0) {
                            badge.textContent = `ã‚ãªãŸã¸ã®æ–°ç€ãƒ¬ã‚¹: ${unreadStatus[item.id]}ä»¶`;
                          } else {
                            container.style.display = 'none';
                          }
                      }
                  }
              }
          });
          activeUnreadListeners.push({ ref: postsRef, type: 'child_changed', callback: changeCallback });
      }
    }
  }

  async function renderApp(){
    exitEditMode();
    cleanupListeners();
    currentViewers = 0;
    refreshHeader();
    setupActionListeners(document.getElementById('app'));
    
    const h=location.hash||'#';
    
    if (h.startsWith('#thread-')) {
      await renderThread(h.replace('#thread-',''));
    } else if (h === '#history') {
      renderHistoryPage();
    } else if (h === '#settings') {
      renderSettingsPage();
    } else {
      renderHome();
      const ref = db.ref('threadMetadata');
      let initialDataLoaded = false;
      const listeners = [];

      ref.orderByChild('lastUpdatedAt').once('value', s => {
        stopLoadingAnimation();
        allThreads = s.val() ? Object.values(s.val()).filter(t => t && t.id).sort((a,b)=>b.lastUpdatedAt-a.lastUpdatedAt) : [];
        if (typeof window.performDisplay === 'function') performDisplay();
        initialDataLoaded = true;

        const addedCallback = ref.orderByChild('createdAt').startAt(Date.now()).on('child_added', snap => {
            if (!initialDataLoaded) return;
            const newThread = snap.val();
            if (newThread && !allThreads.some(t => t.id === newThread.id)) {
                allThreads.unshift(newThread);
                if (typeof window.performDisplay === 'function') performDisplay();
            }
        });
        listeners.push({ ref: ref, type: 'child_added', callback: addedCallback });
        
        const changedCallback = ref.on('child_changed', snap => {
            if (!initialDataLoaded) return;
            const updatedThread = snap.val();
            const index = allThreads.findIndex(t => t.id === updatedThread.id);
            if (index !== -1) {
                allThreads[index] = updatedThread;
                if (typeof window.performDisplay === 'function') performDisplay();
            }
        });
        listeners.push({ ref: ref, type: 'child_changed', callback: changedCallback });
        activeDataListener = listeners;
      }, e => { 
        stopLoadingAnimation(); console.error(e); 
        const container = document.getElementById('threadListContainer');
        if(container) container.innerHTML = `<div class="card"><div class="banned-note">ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</div></div>`;
      });
    }
  }
  
  window.castVote = async (threadId, postId, option) => {
    try {
        const postTextSnapshot = await db.ref(`threads/${threadId}/posts/${postId}/text`).once('value');
        const postText = postTextSnapshot.val();
        if (!postText) return;

        const voteMatch = postText.match(/\[vote\((\d+)\):/);
        if (voteMatch) {
            const deadlineTimestamp = parseInt(voteMatch[1], 10);
            if (deadlineTimestamp > 0 && Date.now() > deadlineTimestamp) {
                alert('ã“ã®ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆã¯ç· ã‚åˆ‡ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚');
                return;
            }
        }
        
        const ref = db.ref(`threads/${threadId}/posts/${postId}/votes/${getUser().permanentId}`);
        ref.transaction(currentVote => {
            return currentVote === option ? null : option;
        });
    } catch (e) {
        console.error("æŠ•ç¥¨ã«å¤±æ•—:", e);
        alert("æŠ•ç¥¨ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
    }
  };

  document.getElementById('homeBtn').onclick=goHome;
  document.getElementById('historyBtn').onclick=()=>location.hash='#history';
  document.getElementById('settingsBtn').onclick=()=>location.hash='#settings';
  document.getElementById('refreshBtn').onclick=()=>renderApp();
  document.getElementById('themeToggleBtn').onclick=()=>{const cT=localStorage.getItem(THEME_KEY)||'light';const nT=cT==='light'?'dark':'light';localStorage.setItem(THEME_KEY,nT);applyTheme(nT);};
  document.getElementById('closeProfileBtn').onclick=window.closeUserProfile;
  document.getElementById('profileModal').onclick=(e)=>{if(e.target===e.currentTarget)window.closeUserProfile();};
  const lightbox = document.getElementById('imageLightbox');
  lightbox.onclick=()=>lightbox.style.display='none';
  const anchorModal = document.getElementById('anchorModal');
  document.getElementById('closeAnchorModalBtn').onclick=()=>anchorModal.style.display='none';
  anchorModal.onclick=(e)=>{if(e.target===e.currentTarget)anchorModal.style.display='none';};

  applyTheme(localStorage.getItem(THEME_KEY)||'light');
  window.addEventListener('hashchange', renderApp);
  
  awardDailyBonusIfNeeded();
  setupUnreadListeners(); 
  
  setInterval(() => {
    document.querySelectorAll('.vote-countdown').forEach(el => {
      const deadline = parseInt(el.dataset.deadline, 10);
      const timeLeft = deadline - Date.now();
      const newText = formatTimeLeft(timeLeft);
      if (el.textContent !== newText) {
          el.textContent = newText;
      }
      if (timeLeft <= 0) {
          el.classList.remove('vote-countdown');
      }
    });
  }, 1000);

  renderApp();

  function setupActionListeners(container) {
    if (!container) return;
    appActionListener = async (e) => {
        const target = e.target.closest('[data-action]');
        if (!target) return;
        
        const { action, threadId, postId, reac, name, id, dailyId, isopadm, num, voteOption } = target.dataset;

        switch (action) {
            case 'react': window.react(threadId, postId, reac); break;
            case 'delete-post': window.deletePost(threadId, postId); break;
            case 'edit-post': window.editPost(threadId, postId); break;
            case 'show-profile': window.showUserProfile(name, id, dailyId, isopadm === 'true'); break;
            case 'open-lightbox': lightbox.style.display='flex'; document.getElementById('lightboxImage').src=target.src; break;
            case 'delete-thread':
                if(confirm('æœ¬å½“ã«ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚')){
                    try {
                        const updates = {};
                        updates['/threads/' + threadId] = null;
                        updates['/threadMetadata/' + threadId] = null;
                        updates['/viewers/' + threadId] = null;
                        await db.ref().update(updates);
                        allThreads = allThreads.filter(t => t.id !== threadId);
                        alert('ã‚¹ãƒ¬ãƒƒãƒ‰ã®å‰Šé™¤ã«æˆåŠŸã—ã¾ã—ãŸã€‚');
                        goHome();
                    } catch (err) { alert('ã‚¹ãƒ¬ãƒƒãƒ‰ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); }
                }
                break;
            case 'quote':
                e.preventDefault();
                const targetPost = document.querySelector(`.post:nth-child(${num})`);
                if (targetPost) {
                    targetPost.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    targetPost.style.transition = 'background-color 0.5s';
                    targetPost.style.backgroundColor = 'rgba(21,101,192,0.1)';
                    setTimeout(() => { targetPost.style.backgroundColor = ''; }, 2000);
                }
                break;
            case 'insert-quote-number':
                 e.preventDefault();
                const replyTextarea = document.getElementById('replyText');
                if (replyTextarea) {
                    replyTextarea.value += `>>${num} `;
                    replyTextarea.focus();
                }
                break;
            case 'vote': window.castVote(threadId, postId, voteOption); break;
            case 'show-anchors': window.showAnchors(postId, threadId); break;
        }
    };
    container.addEventListener('click', appActionListener);
  }
}
</script>
</body>
</html>