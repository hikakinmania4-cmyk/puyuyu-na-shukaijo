<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<!-- â˜…â˜…â˜… ä¿®æ­£ç‚¹1: favicon 404ã‚¨ãƒ©ãƒ¼å¯¾ç­– â˜…â˜…â˜… -->
<link rel="icon" href="data:;base64,iVBORw0KGgo=">
<title>ğŸ¥ºã·ã‚†ã‚†ãªé›†ä¼šå ´ğŸ¥º - ã·ã‚†ã‚†å¥½ãã®ãŸã‚ã®åŒ¿åæ²ç¤ºæ¿</title>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3356676583771209"
     crossorigin="anonymous"></script>
<meta name="description" content="ã·ã‚†ã‚†ğŸ¥ºå¥½ããŒã“ãã£ã¦é›†ã¾ã‚‹ã¨å™‚ã®æ²ç¤ºæ¿" />
<meta name="keywords" content="æ²ç¤ºæ¿,åŒ¿å,é›‘è«‡,è¶£å‘³,ã·ã‚†ã‚†" />
<meta property="og:title" content="ğŸ¥ºã·ã‚†ã‚†ãªé›†ä¼šå ´ğŸ¥º" />
<meta property="og:description" content="ã·ã‚†ã‚†ğŸ¥ºå¥½ããŒã“ãã£ã¦é›†ã¾ã‚‹ã¨å™‚ã®æ²ç¤ºæ¿" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://puyuyu-na-syukaijo.com/" />
<meta property="og:image" content="https://i.ibb.co/93Stdh8x/96a86591b41f.jpg" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="author" content="puyuyu" />
<meta name="theme-color" content="#1565c0" />
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-functions.js"></script>
<style>
  :root{--primary:#1565c0;--accent:#0288d1;--bg:#f5f7fb;--card:#ffffff;--muted:#6b7280;--danger:#ef4444;--text-main:#111827;--text-muted:#6b7280;--border-color:#e5e7eb;}
  .dark-mode{--primary:#60a5fa;--accent:#38bdf8;--bg:#111827;--card:#1f2937;--muted:#9ca3af;--text-main:#f9fafb;--text-muted:#9ca3af;--border-color:#374151;}
  *{box-sizing:border-box}
  body{
    font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Hiragin- Kaku Gothic ProN",Meiryo,sans-serif;
    background:var(--bg);
    margin:0;
    padding:0 0 80px 0; /* ãƒ•ãƒƒã‚¿ãƒ¼ã®é«˜ã•åˆ† + ä½™ç™½ */
    color:var(--text-main);
    transition:background-color .3s,color .3s;
    overflow-x: hidden;
  }
  body.menu-open {
    overflow: hidden;
  }
  header{
    color: #fff;
    background: var(--primary);
    text-align: center;
    padding: 8px 16px;
    border-bottom: 1px solid var(--accent);
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  }
  header h1{margin:0;font-size:20px;font-weight:bold;word-break:break-all; cursor: pointer; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);}
  header .userbox{font-size:12px; margin-top: 4px; opacity: 0.9;}

  .banner-container {
    height: 120px;
    background-color: var(--bg);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 8px;
    position: relative;
    overflow: hidden;
    line-height: 0;
  }
 .banner-slideshow img {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    opacity: 0;
    /* â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒç©¶æ¥µæœ€çµ‚å¥¥ç¾© â˜…â˜…â˜… */
    visibility: hidden; /* æ™®æ®µã¯è¦‹ãˆãªã„ã ã‘ã§ãªãã€Œå­˜åœ¨ã€ã—ãªã„ */
    z-index: 1;         /* éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã¯ä¸‹å±¤ã¸ */
    transition: opacity 0.6s ease-in-out, visibility 0s 0.6s; /* é€æ˜åº¦ãŒæ¶ˆãˆãŸç¬é–“ã«å­˜åœ¨ã‚‚æ¶ˆã™ï¼ */
  }
  .banner-slideshow img.active {
    opacity: 1;
    /* â˜…â˜…â˜… ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ãªã£ãŸç¬é–“ã«ã€Œå­˜åœ¨ã€ã•ã›ã‚‹ï¼ â˜…â˜…â˜… */
    visibility: visible; /* å§¿ã‚’è¦‹ã›ã‚ï¼ */
    z-index: 2;          /* ãã—ã¦æœ€å‰é¢ã«ç«‹ã¦ï¼ */
    transition: opacity 0.6s ease-in-out; /* é€æ˜åº¦ã ã‘ã‚’æ»‘ã‚‰ã‹ã«å¤‰åŒ–ã•ã›ã‚‹ */
  }
  
  .headline-wrapper {
      display: none;
  }
  .headline-wrapper .card {
    margin-top: 16px;
  }
  .headline-item {
    display: block;
    padding: 6px 0;
    font-size: 13px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    border-bottom: 1px solid var(--border-color);
  }
  .headline-item:last-child {
    border-bottom: none;
  }
  .headline-item a {
    color: var(--text-main);
    text-decoration: none;
    transition: color 0.2s;
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .headline-title {
    font-weight: bold;
    color: var(--primary);
    white-space: nowrap;
    flex-shrink: 0;
  }
  .headline-res-count {
    color: var(--text-muted);
    white-space: nowrap;
    flex-shrink: 0;
  }
  .headline-text {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-grow: 1;
    min-width: 0;
  }
  .headline-time {
    color: var(--text-muted);
    font-size: 12px;
    white-space: nowrap;
    flex-shrink: 0;
    margin-left: auto;
  }

  .footer-nav {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 65px;
    background: var(--card);
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-around;
    align-items: center;
    box-shadow: 0 -3px 12px rgba(0,0,0,0.1);
    z-index: 1500;
  }
  .nav-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 4px;
    background: none;
    border: none;
    color: var(--text-muted);
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    padding: 8px 4px;
    border-radius: 8px;
    flex: 1;
    height: 100%;
    transition: background-color 0.2s, color 0.2s;
    position: relative;
    text-align: center;
  }
  .nav-btn:hover {
    color: var(--primary);
  }
  .nav-btn.active {
    color: var(--primary);
    font-weight: bold;
  }
  .nav-btn .icon {
    font-size: 22px;
    line-height: 1;
  }
  .nav-btn.create-thread {
    color: white;
    font-weight: bold;
    background: var(--primary);
    border-radius: 50%;
    width: 60px;
    height: 60px;
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    border: 4px solid var(--bg);
    box-shadow: 0 0 15px rgba(0,0,0,0.2);
    flex: 0 0 60px;
  }
  .nav-btn.create-thread:hover {
    background: var(--accent);
  }
  .nav-btn.create-thread .icon {
    font-size: 28px;
  }
  .nav-badge {
    position:absolute;
    top:4px;
    right: 50%;
    transform: translateX(20px);
  }

  .side-menu-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 1900;
    opacity: 0;
    visibility: hidden;
    transition: opacity .3s, visibility .3s;
  }
  .side-menu {
    position: fixed;
    top: 0;
    right: -280px;
    width: 260px;
    height: 100%;
    background: var(--bg);
    z-index: 2000;
    transition: right .3s ease-out;
    display: flex;
    flex-direction: column;
    padding: 20px;
    border-left: 1px solid var(--border-color);
  }
  body.menu-open .side-menu-overlay {
    opacity: 1;
    visibility: visible;
  }
  body.menu-open .side-menu {
    right: 0;
  }
  .side-menu h2 {
    margin: 0 0 20px 0;
    font-size: 20px;
    color: var(--primary);
  }
  .side-menu a, .side-menu button {
    color: var(--text-main);
    text-decoration: none;
    font-size: 16px;
    padding: 12px 0;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    gap: 10px;
    background: none;
    border: none;
    cursor: pointer;
    width: 100%;
    text-align: left;
  }
  .side-menu a:hover, .side-menu button:hover {
    color: var(--primary);
  }
  .wrap{max-width:1000px;margin:0 auto;padding:12px}
  .card{background:var(--card);border-radius:10px;padding:12px;box-shadow:0 2px 6px rgba(2,6,23,0.06);margin-bottom:12px;border:1px solid var(--border-color); transition: background-color .3s, border-color .3s;}
  
  /* â˜…â˜…â˜… [CSSè¿½åŠ ] ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤ºã®ã‚¹ã‚¿ã‚¤ãƒ« â˜…â˜…â˜… */
  .loading-indicator-frame {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 40px 20px;
      font-size: 16px;
      color: var(--text-muted);
      min-height: 150px; /* æœ€å°é«˜ã•ã‚’ç¢ºä¿ã—ã¦ã‚¬ã‚¿ãƒ„ã‚­ã‚’é˜²ã */
  }
  
  .card h2{margin:0 0 8px 0;font-size:16px;color:var(--primary);word-break:break-all;}
  .thread-header{display:flex;flex-wrap:nowrap;justify-content:space-between;align-items:flex-start;gap:16px;}
  .thread-header-main{min-width:0;flex-grow:1;}
  .thread-header-meta{text-align:right;flex-shrink:0;}
  input[type="text"],textarea,select{width:100%;padding:8px;border:1px solid var(--border-color);border-radius:8px;font-size:14px;background:var(--card);color:var(--text-main);}
  textarea{min-height:80px;resize:vertical}
  .btn{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;transition:background-color 0.2s;}
  .btn:disabled{background:var(--muted);cursor:not-allowed;}
  .btn.warn{background:var(--danger)}
  .btn.small{padding:6px 8px;font-size:13px;border-radius:6px}
  .btn.liked{background:#e11d48;color:white;}
  .search-box{display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap;}
  .sort-box{display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap; align-items: center;}
  .thread-item, .history-item{padding:10px;border-radius:8px;border:1px solid var(--border-color);display:flex;flex-wrap:nowrap;align-items:center;gap:12px; margin-bottom: 8px;}
  .thread-link{font-weight:600;color:var(--primary);text-decoration:none; display:block;word-break:break-all;}
  .thread-info { flex-grow: 1; display: flex; min-width: 0; }
  .thread-item .thread-info { flex-direction: column; align-items: flex-start; gap: 4px; }
  .history-item .thread-info { flex-direction: column; align-items: flex-start; gap: 4px; position: relative; padding-bottom: 18px; }
  .history-item-res-count { position: absolute; bottom: 0; left: 0; }
  .history-achievement-notify { font-weight: bold; color: var(--primary); font-size: 13px; margin-top: 4px; }
  .thread-tags{display:flex;flex-wrap:wrap;gap:4px;}
  .tag{background:var(--muted);color:var(--text-main);padding:2px 6px;border-radius:4px;font-size:11px;cursor:pointer; text-decoration: none;}
  .thread-title-wrapper{min-width:0;display:flex;align-items:center;gap:8px;}
  .thread-meta-info{display:flex;flex-direction:column;align-items:flex-end;flex-shrink:0;text-align:right;}
  .thread-preview-img{width:60px;height:60px;object-fit:cover;border-radius:6px;flex-shrink:0;}
  .meta{font-size:13px;color:var(--text-muted)}
  .post{padding:10px;border-top:1px solid var(--border-color);margin-top:8px;}
  #postsContainer > .post:first-child{margin-top:0;}
  .modal-body .post {border-top:none; border-bottom:1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 10px;}
  .modal-body .post:last-child {border-bottom:none; margin-bottom:0;}
  .post .meta{font-size:12px;color:var(--text-muted);display:flex;gap:8px;align-items:center;flex-wrap:wrap; margin-bottom: 8px;}
  .post .meta .no{color:var(--accent);cursor:pointer;font-weight:700}
  .post .meta .post-author{font-weight:bold;cursor:pointer; color: var(--text-main);}
  .post .body{white-space:pre-wrap;word-break:break-word}
  .post .body a{color:var(--primary);}
  .post-image{max-width:280px;height:auto;border-radius:6px;margin-top:8px;display:block;cursor:pointer}
  .highlight{background-color: yellow; color: black;}
  .controls{margin-top:8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
  .timestamp{margin-left:auto; white-space:nowrap;}
  .badge-op, .badge-level{background:var(--primary);color:white;padding:3px 6px;border-radius:999px;font-size:12px; white-space:nowrap;}
  .badge-new, .badge-anchor{display:inline-flex;align-items:center;justify-content:center;min-width:18px;height:18px;border-radius:999px;background:var(--danger);color:white;font-size:11px;font-weight:bold;padding:0 5px;}
  #achievementBadge { background-color: #1565c0; }
  .unread-notification{margin-top:4px;}
  .unread-notification .badge-new{font-size:12px;padding:3px 8px;}
  .badge-anchor{cursor:pointer;}
  .banned-note, .deleted-note, .ng-hidden-post{color:var(--danger);font-weight:700;margin-top:8px;}
  .ng-word-red{color:var(--danger);font-weight:bold;}
  .thread-link.ng-word-red { color: var(--danger); }
  .search-highlight {
    color: var(--danger);
    font-weight: bold;
    background-color: rgba(239, 68, 68, 0.1);
  }
  .dice-result {
    color: #ff8c00;
    font-weight: bold;
  }
  .small-muted{font-size:12px;color:var(--text-muted)}
  .modal-overlay,.lightbox-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:1000;}
  .modal-content{background:var(--bg);border-radius:10px;width:90%;max-width:600px;max-height:80%;display:flex;flex-direction:column;border:1px solid var(--border-color);}
  .modal-header{padding:12px 16px;border-bottom:1px solid var(--border-color);display:flex;justify-content:space-between;align-items:center;}
  .modal-header h2{font-size:18px;color:var(--primary);margin:0;}
  .modal-close-btn,.lightbox-close-btn{font-size:28px;background:none;border:none;cursor:pointer;color:white;position:absolute;top:10px;right:15px;}
  .modal-close-btn{color:var(--text-muted);position:static;}
  .modal-body{padding:16px;overflow-y:auto;}
  #profileId{color:var(--text-muted);font-size:13px;margin:0 0 12px 0;word-break:break-all;}
  #profileControls{margin-bottom:12px; border-top:1px solid var(--border-color); padding-top:12px; display:flex; gap:8px;}
  .lightbox-content img{max-width:90vw;max-height:90vh;display:block;}
  .vote-box{margin-top:10px; display:flex; flex-direction:column; gap: 5px;}
  .vote-option-bar-container{display: flex; align-items: center; gap: 8px; padding: 4px; border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer; transition: background-color .2s;}
  .vote-option-bar-container:hover{background-color: rgba(128,128,128,0.1);}
  .vote-option-bar-container.voted-by-user{border-color: var(--primary); background-color: rgba(21,101,192,0.08);}
  .vote-option-bar-container.expired{cursor:not-allowed;}
  .vote-option-bar-container.expired:hover{background-color: transparent;}
  .vote-label{flex-shrink: 0; font-size: 14px;}
  .vote-bar-wrapper{flex-grow: 1; background-color: var(--border-color); border-radius: 4px; height: 20px; overflow: hidden;}
  .vote-option-bar{background-color: var(--accent); height: 100%; transition: width .3s ease-out, background-color .3s;}
  .vote-result{font-size: 13px; font-weight: bold; min-width: 60px; text-align: right;}
  .pagination-controls{display:flex;justify-content:center;align-items:center;gap:12px;margin-top:16px;}
  .achievement-item { display: flex; align-items: center; gap: 12px; padding: 8px 0; border-bottom: 1px solid var(--border-color); }
  .achievement-item:last-child { border-bottom: none; }
  .achievement-info { flex-grow: 1; }
  .achievement-title { font-weight: bold; }
  .achievement-desc { font-size: 12px; color: var(--text-muted); }
  .achievement-status { font-size: 12px; font-weight: bold; padding: 4px 8px; border-radius: 999px; }
  .status-unlocked { background-color: #4caf50; color: white; }
  .status-locked { background-color: var(--muted); color: var(--text-main); }
  @keyframes shake-animation {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
    20%, 40%, 60%, 80% { transform: translateX(5px); }
  }
  @keyframes rainbow-animation {
    0%,100% { color: red; } 16% { color: orange; } 33% { color: yellow; } 50% { color: green; } 66% { color: blue; } 83% { color: indigo; }
  }
  .effect-shake-active { animation: shake-animation 0.5s ease-in-out 6; }
  .effect-rainbow-active .body { animation: rainbow-animation 2s linear infinite; }
  .embed-container { position: relative; overflow: hidden; width: 100%; padding-top: 56.25%; margin: 8px 0; border-radius: 6px; }
  .embed-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }
  .embedded-video { max-width: 100%; border-radius: 6px; margin-top: 8px; }
  .twitter-tweet { margin: 16px auto !important; }
  #drawingCanvas { border: 1px solid var(--border-color); border-radius: 6px; touch-action: none; cursor: crosshair; }
  .drawing-controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; margin-top: 10px; }
  .drawing-controls label { font-size: 13px; }
  .drawing-controls input[type="color"] { width: 40px; height: 30px; padding: 2px; border: none; border-radius: 4px; cursor: pointer; background: none; }
  .drawing-controls input[type="range"] { flex-grow: 1; }
  .drawing-controls .tool-btn { font-size: 13px; padding: 6px 8px; line-height: 1; }
  .drawing-controls .tool-btn.active { background-color: var(--primary); color: white; }
  #drawingModal .modal-content { max-width: 95%; width: auto; max-width: 1020px; }
  #drawingPreviewContainer { margin-top: 8px; }
  #drawingPreview { max-width: 150px; border-radius: 6px; border: 1px solid var(--border-color); }
  #clearDrawingBtn { margin-left: auto; }
  @media(max-width:680px){
    .nav-btn { font-size: 9px; }
    .nav-btn.create-thread { width: 50px; height: 50px; top: -20px;}
    .nav-btn.create-thread .icon { font-size: 24px; }
  }
</style>
</head>
<body>
  <header>
    <div class="header-content">
      <h1>ğŸ¥ºã·ã‚†ã‚†ãªé›†ä¼šå ´ğŸ¥º</h1>
      <div class="userbox"><span id="userDisplay"></span></div>
    </div>
  </header>

  <div class="banner-container">
      <div class="banner-slideshow" id="bannerSlideshow"></div>
  </div>
  
  <div class="wrap">
    <div class="headline-wrapper" id="headlineWrapper">
      <div class="card">
        <h2>ãƒ˜ãƒƒãƒ‰ãƒ©ã‚¤ãƒ³</h2>
        <div id="headlineContainer">
          <!-- JavaScriptã«ã‚ˆã£ã¦å†…å®¹ãŒè¿½åŠ ã•ã‚Œã¾ã™ -->
        </div>
      </div>
    </div>
    <div id="app"></div>
  </div>

  <div class="side-menu-overlay" id="sideMenuOverlay"></div>
  <div class="side-menu" id="sideMenu">
    <h2>ãƒ¡ãƒ‹ãƒ¥ãƒ¼</h2>
    <a href="#terms">ğŸ“œ åˆ©ç”¨è¦ç´„</a>
    <a href="#memories">ğŸ† ãƒ¡ãƒ¢ãƒªãƒ¼ã‚º</a>
    <a href="#" id="contactAdminLink">âœ‰ï¸ ç®¡ç†äººã¸ã®é€£çµ¡</a>
    <button id="themeToggleBtn">ğŸŒ™ ãƒ†ãƒ¼ãƒåˆ‡æ›¿</button>
  </div>
  
  <div class="footer-nav">
    <button class="nav-btn" id="navHomeBtn">
      <span class="icon">ğŸ </span>
      <span>ãƒ›ãƒ¼ãƒ /æ›´æ–°</span>
    </button>
    <button class="nav-btn" id="navHistoryBtn">
      <span class="icon">ğŸ“œ</span>
      <span>å±¥æ­´</span>
      <span id="navHistoryUnreadBadge" class="badge-new nav-badge" style="display:none;"></span>
    </button>
    <button class="nav-btn create-thread" id="navCreateThreadBtn">
      <span class="icon">ğŸ’¬+</span>
    </button>
    <button class="nav-btn" id="navSettingsBtn">
      <span class="icon">âš™ï¸</span>
      <span>è¨­å®š</span>
    </button>
    <button class="nav-btn" id="navMenuBtn">
      <span class="icon">â˜°</span>
      <span>ãƒ¡ãƒ‹ãƒ¥ãƒ¼</span>
    </button>
  </div>
  
  <div id="createThreadModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h2>æ–°ã—ã„ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½œæˆ</h2>
        <button id="closeCreateThreadModalBtn" class="modal-close-btn">&times;</button>
      </div>
      <div class="modal-body">
        <input id="newTitle" type="text" placeholder="ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆ#ã‚¿ã‚° ã§ã‚¿ã‚°ä»˜ã‘ã§ãã¾ã™ï¼‰" style="margin-bottom:8px;">
        <input id="newName" type="text" placeholder="åå‰ï¼ˆä»»æ„ï¼‰" style="margin-bottom:8px;">
        <textarea id="newText" placeholder="æœ¬æ–‡"></textarea>
        <div class="controls" style="justify-content:flex-start; margin-top:8px; gap:8px;">
          <button id="createVoteBtn" class="btn small">ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆä½œæˆ</button>
          <button id="createDrawBtn" class="btn small">ğŸ¨ ãŠçµµæã</button>
        </div>
        <div style="margin-top:8px;">
          <label for="levelRestrictionSelect" class="small-muted">ãƒ¬ãƒ™ãƒ«åˆ¶é™:</label>
          <select id="levelRestrictionSelect">
            <option value="0">ç„¡åˆ¶é™</option>
            <option value="10">Lv.10ä»¥ä¸Š</option>
            <option value="30">Lv.30ä»¥ä¸Š</option>
            <option value="60">Lv.60ä»¥ä¸Š</option>
            <option value="250">Lv.250ä»¥ä¸Š</option>
            <option value="500">Lv.500ä»¥ä¸Š</option>
            <option value="1000">Lv.1000ä»¥ä¸Š</option>
          </select>
        </div>
        <div style="margin-top:8px; display:flex; justify-content:space-between; align-items:center;">
          <div id="newImageContainer">
            <input id="newImage" type="file" accept="image/*">
          </div>
          <button class="btn" id="createThreadBtn">ã‚¹ãƒ¬ä½œæˆ</button>
        </div>
      </div>
    </div>
  </div>

  <div id="profileModal" class="modal-overlay"><div class="modal-content"><div class="modal-header"><h2 id="profileName"></h2><button id="closeProfileBtn" class="modal-close-btn">&times;</button></div><div class="modal-body"><p id="profileId"></p><div id="profileControls"></div><h3>ã“ã®äººã®æŠ•ç¨¿</h3><div id="profilePostsList"></div></div></div></div>
  <div id="imageLightbox" class="lightbox-overlay"><div class="lightbox-content"><img id="lightboxImage" src=""><button id="lightboxClose" class="lightbox-close-btn">&times;</button></div></div>
  <div id="voteModal" class="modal-overlay"><div class="modal-content"><div class="modal-header"><h2>ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆä½œæˆ</h2><button id="closeVoteModalBtn" class="modal-close-btn">&times;</button></div><div class="modal-body"><h4>æŠ•ç¥¨æœŸé™</h4><select id="voteDeadlineSelect" style="width:100%;margin-bottom:12px;"><option value="0">ç„¡æœŸé™</option><option value="60000">1åˆ†</option><option value="180000">3åˆ†</option><option value="300000">5åˆ†</option><option value="900000">15åˆ†</option><option value="1800000">30åˆ†</option><option value="3600000">1æ™‚é–“</option><option value="21600000">6æ™‚é–“</option><option value="86400000">1æ—¥</option><option value="259200000">3æ—¥</option></select><h4>é¸æŠè‚¢</h4><div id="voteOptionsContainer"><input type="text" class="vote-option-input" placeholder="é¸æŠè‚¢1" style="margin-bottom:8px;"><input type="text" class="vote-option-input" placeholder="é¸æŠè‚¢2" style="margin-bottom:8px;"></div><button id="addVoteOptionBtn" class="btn small">é¸æŠè‚¢ã‚’è¿½åŠ </button><div style="text-align:right; margin-top:16px;"><button id="insertVoteBtn" class="btn">æœ¬æ–‡ã«æŒ¿å…¥</button></div></div></div></div>
  <div id="anchorModal" class="modal-overlay"><div class="modal-content"><div class="modal-header"><h2>ã“ã®æŠ•ç¨¿ã¸ã®è¿”ä¿¡</h2><button id="closeAnchorModalBtn" class="modal-close-btn">&times;</button></div><div class="modal-body" id="anchorModalBody"></div></div></div>
  
  <div id="drawingModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h2>ãŠçµµæã</h2>
        <button id="closeDrawingModalBtn" class="modal-close-btn">&times;</button>
      </div>
      <div class="modal-body">
        <div class="drawing-controls">
           <label for="canvasSizeSelect" class="small-muted">ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚º:</label>
           <select id="canvasSizeSelect">
             <option value="480x360">4:3 æ¨™æº– (480x360)</option>
             <option value="640x360">16:9 ãƒ¯ã‚¤ãƒ‰ (640x360)</option>
             <option value="480x480">1:1 æ­£æ–¹å½¢ (480x480)</option>
             <option value="360x480">3:4 ç¸¦é•· (360x480)</option>
             <option value="1000x200">5:1 ãƒãƒŠãƒ¼ (1000x200)</option>
           </select>
        </div>
        <canvas id="drawingCanvas" width="480" height="360" style="margin-top: 10px;"></canvas>
        <div class="drawing-controls">
          <label for="bgColorPicker">èƒŒæ™¯</label>
          <input type="color" id="bgColorPicker" value="#FFFFFF">
          <label for="colorPicker">ãƒšãƒ³è‰²</label>
          <input type="color" id="colorPicker" value="#000000">
          <label for="brushSize" style="flex-grow: 1;">å¤ªã•: <span id="brushSizeValue">5</span></label>
          <input type="range" id="brushSize" min="1" max="50" value="5" style="flex-grow: 2;">
        </div>
        <div class="drawing-controls" style="margin-top: 16px;">
          <label>ãƒ„ãƒ¼ãƒ«:</label>
          <button id="penBtn" class="btn small tool-btn active">ãƒšãƒ³</button>
          <button id="markerBtn" class="btn small tool-btn">ãƒãƒ¼ã‚«ãƒ¼</button>
          <button id="sprayBtn" class="btn small tool-btn">ã‚¹ãƒ—ãƒ¬ãƒ¼</button>
          <button id="fillBtn" class="btn small tool-btn">å¡—ã‚Šã¤ã¶ã—</button>
          <button id="eraserBtn" class="btn small tool-btn">æ¶ˆã—ã‚´ãƒ </button>
          <div style="margin-left:auto; display:flex; gap: 10px;">
            <button id="undoBtn" class="btn small tool-btn">æˆ»ã‚‹</button>
            <button id="redoBtn" class="btn small tool-btn">é€²ã‚€</button>
            <button id="clearCanvasBtn" class="btn small warn tool-btn">å…¨æ¶ˆã—</button>
          </div>
        </div>
        <div style="text-align:right; margin-top:16px;">
          <button id="insertDrawingBtn" class="btn">æŠ•ç¨¿ã«æ·»ä»˜</button>
        </div>
      </div>
    </div>
  </div>

  <div id="contactModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h2>ç®¡ç†äººã¸ã®é€£çµ¡</h2>
        <button id="closeContactModalBtn" class="modal-close-btn">&times;</button>
      </div>
      <div class="modal-body">
        <p>ç®¡ç†äººã¸ç§˜åŒ¿ã§é€£çµ¡ã—ãŸã„ã“ã¨ãªã©ã‚ã‚Œã°ã€ã“ã¡ã‚‰ã¸ã”é€£çµ¡ãã ã•ã„ã€‚</p>
        <p style="font-weight: bold; text-align: center; margin-top: 16px;">
          <a href="mailto:puyuyu.kanrinin.dayo@gmail.com">
            puyuyu.kanrinin.dayo@gmail.com
          </a>
        </p>
      </div>
    </div>
  </div>
  
  <!-- â˜…â˜…â˜… ä¿®æ­£ç‚¹2: ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿã‚¨ãƒ©ãƒ¼å¯¾ç­– â˜…â˜…â˜… -->
  <audio id="notificationSound" src="https://cdn.jsdelivr.net/gh/pixel-sound/pixel-sound-effects@1.0.1/mp3/notification-1.mp3" preload="auto"></audio>

<script>
// (ã“ã“ã‹ã‚‰ä¸‹ã€JSå…¨æ–‡)
const firebaseConfig = {
  apiKey: "AIzaSyDS3Tlr9Oc4z5Kz2Zg72p9VRayPSAbmwTw",
  authDomain: "config-f5509.firebaseapp.com",
  databaseURL: "https://config-f5509-default-rtdb.firebaseio.com",
  projectId: "config-f5509",
  storageBucket: "config-f5509.appspot.com",
  messagingSenderId: "513023904601",
  appId: "1:513023904601:web:1846aa87aec5de306e1a48",
  measurementId: "G-KT2LZC2EED"
};

const ACHIEVEMENTS_MASTER = {
  'mini_wai':     { title: 'ãƒŸãƒ‹ãƒ¯ã‚¤ğŸ¥¹', description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¬ãƒ™ãƒ«5åˆ°é”ã€‚' },
  'puyuyu':       { title: 'ã·ã‚†ã‚†ğŸ¥º', description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¬ãƒ™ãƒ«10åˆ°é”ã€‚' },
  'teriri':       { title: 'ã¦ã‚Šã‚ŠğŸ˜ ', description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¬ãƒ™ãƒ«30åˆ°é”ã€‚' },
  'yumechan':     { title: 'ã‚†ã‚ã¡ã‚ƒã‚“ğŸ¤¥', description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¬ãƒ™ãƒ«60åˆ°é”ã€‚' },
  'saikyo_ode':   { title: 'æœ€å¼·ã®ã€ãŠã§wğŸ˜ƒ', description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¬ãƒ™ãƒ«1000åˆ°é”ã€‚' },
  'matsumoto_san':{ title: 'ã¾ã¤ã‚‚ã¨ã•ã‚“ğŸ‘´', description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¬ãƒ™ãƒ«10000åˆ°é”ã€‚' },
  'hanchou':      { title: 'ãƒãƒ³ãƒãƒ§ã‚¦ğŸ˜', description: '!dice 3d6ã§å‡ºç›®ãŒ4,5,6ï¼ˆé †ä¸åŒï¼‰ã€‚' },
  'eye_puyuyu':   { title: 'â€çœ¼â€ã®ã·ã‚†ã‚†ğŸ§¿', description: 'éš ã—ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã€‚' },
  'king_puyuyu':  { title: 'ğŸ‘‘ã‚­ãƒ³ã‚°ã·ã‚†ã‚†', description: 'è‡ªèº«ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒ1000ãƒ¬ã‚¹ã«åˆ°é”ã€‚' },
  'popular_puyuyu': { title: 'äººæ°—è€…ğŸ¥º', description: 'è‡ªèº«ã®æŠ•ç¨¿ã«ğŸ¥ºã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒ10å€‹ä»˜ãã€‚' },
  'puyuyu_hakase': { title: 'ã·ã‚†ã‚†åšå£«ğŸ¥¸', description: 'ã™ã¹ã¦ã®å®Ÿç¸¾ã‚’è§£é™¤ã™ã‚‹ã€‚' }
};

const NG_WORDS = ['ë°”ë³´', 'ë©ì²­ì´', 'ì£½ì–´', 'æ­»ã­', 'ãƒã‚«', 'é¦¬é¹¿', 'kill', 'idiot'];
const ADMIN_IDS = ['1CUUSoWR72NmU2pfFvtaq4h0iVJ3', 'NnRTlI4xoxZlS4q7UFDwNqN0LNV2', 'gM95dvGTtMcKc9wcBMKpGnI8jcc2'];

document.addEventListener('DOMContentLoaded', () => {
  if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_API_KEY") {
    document.getElementById('app').innerHTML = `<div class="card"><h2>ğŸš¨ è¨­å®šãŒå¿…è¦ã§ã™ï¼</h2><p>HTMLãƒ•ã‚¡ã‚¤ãƒ«å†…ã® <code>firebaseConfig</code> ãŒæœªè¨­å®šã§ã™ã€‚</p></div>`; return;
  }
  try { 
    firebase.initializeApp(firebaseConfig);
  } catch (e) { 
    alert("Firebaseã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); 
    return; 
  }

  const auth = firebase.auth();
  
  auth.onAuthStateChanged((user) => {
    if (user) {
      main();
    } else {
      auth.signInAnonymously().catch(error => {
        console.error("åŒ¿åèªè¨¼ã«å¤±æ•—:", error);
        document.getElementById('app').innerHTML = `<div class="card"><h2>èªè¨¼ã‚¨ãƒ©ãƒ¼</h2><p>æ²ç¤ºæ¿ã®åˆ©ç”¨ã«å¿…è¦ãªèªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚</p></div>`;
      });
    }
  });
});

function main() {
  const db = firebase.database();
  const auth = firebase.auth();
  const functions = firebase.functions();

  let audioContext = null;
  const initAudioContext = () => {
    if (!audioContext) {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }
      } catch (e) {
        console.error("AudioContextã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ", e);
      }
    } else if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
    document.body.removeEventListener('click', initAudioContext, { once: true });
    document.body.removeEventListener('keydown', initAudioContext, { once: true });
  };
  document.body.addEventListener('click', initAudioContext, { once: true });
  document.body.addEventListener('keydown', initAudioContext, { once: true });

  let globalBanList = {};
  let myTotalExp = 0;
  let loadingInterval = null;
  let currentEditState = null;
  let drawingDataUrl = null;
  let heartbeatInterval = null;
  let janitorInterval = null;
  let searchWorker = null;
  let drawingEventListeners = [];
  let bannerInterval = null;

  const banRef = db.ref('globalBan');
  banRef.on('value', (snapshot) => {
      globalBanList = snapshot.val() || {};
      const currentThreadId = location.hash.startsWith('#thread-') ? location.hash.replace('#thread-','') : null;
      if (currentThreadId && document.getElementById('postsContainer')) {
          Promise.all([
              db.ref('threads/' + currentThreadId).once('value'),
              db.ref('userLevels').once('value'),
              db.ref('userAchievements').once('value')
          ]).then(([threadSnapshot, userLevelsSnapshot, achievementsSnapshot]) => {
              const threadData = threadSnapshot.val();
              userLevelsCache = userLevelsSnapshot.val() || {};
              userAchievementsCache = achievementsSnapshot.val() || {};
              if (threadData) {
                // å¿…è¦ãªã‚‰ã“ã“ã§å†æç”»
              }
          });
      }
  });

  let activeDataListener = null, activeViewersListener = null, myConnectionRef = null, allThreads = [], currentViewers = 0, currentPage = 1;
  let activeHeadlineListener = null; 
  let headlineTimeUpdater = null;
  let activeUnreadListeners = [];
  let globalUnreadNotifications = {};
  let initialNotificationsLoaded = false;
  let myPostNumbersCache = {};
  let threadDataCache = {};
  let userLevelsCache = {}; 
  let userAchievementsCache = {};
  let effectObserver = null;
  let activeAchievementListener = null;

  const THREADS_PER_PAGE = 15;

  function cleanupListeners() {
    if(activeDataListener){
        if (Array.isArray(activeDataListener)) {
            activeDataListener.forEach(l => l.ref.off(l.type, l.callback));
        } else if (activeDataListener.ref && activeDataListener.callback) {
            activeDataListener.ref.off('value', activeDataListener.callback);
        }
        activeDataListener = null;
    }
    if(activeViewersListener){ activeViewersListener.ref.off('value', activeViewersListener.callback); activeViewersListener = null; }
    if(myConnectionRef){ myConnectionRef.remove(); myConnectionRef = null; }
    if(effectObserver) { effectObserver.disconnect(); effectObserver = null; }
    if(heartbeatInterval) clearInterval(heartbeatInterval);
    if(janitorInterval) clearInterval(janitorInterval);
    heartbeatInterval = null;
    janitorInterval = null;
    
    drawingEventListeners.forEach(({element, type, handler, options}) => {
        element.removeEventListener(type, handler, options);
    });
    drawingEventListeners = [];
    
    activeUnreadListeners.forEach(l => {
      if (l.ref && l.type && l.callback) {
        l.ref.off(l.type, l.callback);
      }
    });
    activeUnreadListeners = [];

    if (activeAchievementListener) {
        activeAchievementListener.ref.off('value', activeAchievementListener.callback);
        activeAchievementListener = null;
    }
    if (activeHeadlineListener) {
        activeHeadlineListener.ref.off('value', activeHeadlineListener.callback);
        activeHeadlineListener = null;
    }
    if (headlineTimeUpdater) {
      clearInterval(headlineTimeUpdater);
      headlineTimeUpdater = null;
    }
  }
  const PERMANENT_ID_COOKIE = 'puyuyun_permanent_id_v2';
  const DAILY_ID_COOKIE = 'puyuyun_daily_id_v2';
  const USERNAME_COOKIE = 'puyuyun_username_v1';
  const LAST_POST_TIME_KEY = 'puyuyun_last_post_time';
  const EFFECT_COOLDOWN_KEY = 'puyuyun_effect_cooldown';
  const POST_INTERVAL_SECONDS = 10;
  const EFFECT_COOLDOWN_SECONDS = 30;
  const MAX_IMAGE_BYTES = 10 * 1024 * 1024;
  const POST_LIMIT = 1000;
  const TITLE_LIMIT = 25;
  const NAME_LIMIT = 11;
  const TEXT_LIMIT = 1000;
  const MAX_NEWLINES = 30;
  const MAX_CONSECUTIVE_NEWLINES = 2;
  const VOTE_OPTION_LIMIT = 15;
  const HISTORY_KEY = 'puyuyun_history_v1';
  const THEME_KEY = 'puyuyun_theme';
  const NAME_HISTORY_KEY = 'puyuyun_name_history_v1';
  const NG_SETTINGS_KEY = 'puyuyun_ng_settings_v1';
  const SOUND_SETTINGS_KEY = 'puyuyun_sound_settings_v1';
  const NEXT_THREAD_DATA_KEY = 'puyuyun_next_thread_data';
  const DAILY_ACTIVITY_KEY = 'puyuyun_daily_activity_v1';
  
  const REACTION_PAIRS = { 'ğŸ¥º': 'ğŸ¥¹', 'ğŸ˜': 'ğŸ¤“', 'ğŸ˜…': 'ğŸ˜“' };
  const BASE_REACTIONS = Object.keys(REACTION_PAIRS);
  
  // â˜…â˜…â˜… [JSå¤‰æ›´ç‚¹] ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤ºã‚’æ”¹è‰¯ â˜…â˜…â˜…
  function startLoadingAnimation(element, text = 'èª­ã¿è¾¼ã¿ä¸­') {
    if (loadingInterval) clearInterval(loadingInterval);
    
    // ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆã‚«ãƒ¼ãƒ‰ï¼‰ã‚’ä½œæˆ
    const frame = document.createElement('div');
    frame.className = 'card'; // æ—¢å­˜ã®ã‚«ãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æµç”¨

    // ä¸­èº«ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œæˆ
    const content = document.createElement('div');
    content.className = 'loading-indicator-frame'; // æ–°ã—ãè¿½åŠ ã—ãŸã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨

    const emojiSequence = ['ğŸ¥º', 'ğŸŒ”', 'ğŸŒ“', 'ğŸŒ’', 'ğŸŒ‘', 'ğŸŒ˜', 'ğŸŒ—', 'ğŸŒ–', 'ğŸ¤¡'];
    let currentIndex = 0;

    const textSpan = document.createElement('span');
    textSpan.textContent = `${text}â€¦ `;
    const emojiSpan = document.createElement('span');
    emojiSpan.textContent = emojiSequence[currentIndex];
    
    // ä¸­èº«ã‚’ã‚³ãƒ³ãƒ†ãƒŠã«è¿½åŠ 
    content.appendChild(textSpan);
    content.appendChild(emojiSpan);
    
    // ã‚³ãƒ³ãƒ†ãƒŠã‚’ãƒ•ãƒ¬ãƒ¼ãƒ ã«è¿½åŠ 
    frame.appendChild(content);

    // å¯¾è±¡è¦ç´ ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã€ä½œæˆã—ãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æŒ¿å…¥
    element.innerHTML = ''; 
    element.appendChild(frame);

    loadingInterval = setInterval(() => {
        currentIndex = (currentIndex + 1) % emojiSequence.length;
        emojiSpan.textContent = emojiSequence[currentIndex];
    }, 150);
  }

  function stopLoadingAnimation() {
      if (loadingInterval) {
          clearInterval(loadingInterval);
          loadingInterval = null;
      }
  }
  
  function loadNameHistory() { try { return JSON.parse(localStorage.getItem(NAME_HISTORY_KEY)) || []; } catch(e) { return []; } }
  function saveNameHistory(history) { localStorage.setItem(NAME_HISTORY_KEY, JSON.stringify(history)); }
  function loadNgSettings() { try { return JSON.parse(localStorage.getItem(NG_SETTINGS_KEY)) || {}; } catch(e) { return {}; } }
  function saveNgSettings(settings) { localStorage.setItem(NG_SETTINGS_KEY, JSON.stringify(settings)); }
  function loadSoundSettings() { try { return JSON.parse(localStorage.getItem(SOUND_SETTINGS_KEY)) || { enabled: true }; } catch(e) { return { enabled: true }; } }
  function saveSoundSettings(settings) { localStorage.setItem(SOUND_SETTINGS_KEY, JSON.stringify(settings)); }
  function loadDailyActivity() { try { return JSON.parse(localStorage.getItem(DAILY_ACTIVITY_KEY)) || { date: '', postCount: 0 }; } catch(e) { return { date: '', postCount: 0 }; } }
  function saveDailyActivity(activity) { localStorage.setItem(DAILY_ACTIVITY_KEY, JSON.stringify(activity)); }

  function uid(l=10){return Math.random().toString(36).slice(2,2+l).toUpperCase();}
  function setCookie(n,v,d=365){const e=new Date();e.setTime(e.getTime()+(d*24*60*60*1000));document.cookie=`${n}=${encodeURIComponent(v)};expires=${e.toUTCString()};path=/;SameSite=Lax;Secure`;}
  function getCookie(n){const kv=document.cookie.split(';').map(s=>s.trim()).find(s=>s.startsWith(n+'='));return kv?decodeURIComponent(kv.split('=')[1]):null;}
  function escapeHTML(s){if(s==null)return '';return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;');}
  function formatTimestamp(ts) {
    const d = new Date(ts);
    const M = (d.getMonth() + 1).toString().padStart(2, '0');
    const D = d.getDate().toString().padStart(2, '0');
    const h = d.getHours().toString().padStart(2, '0');
    const m = d.getMinutes().toString().padStart(2, '0');
    return `${M}/${D} ${h}:${m}`;
  }
  function formatTimeLeft(timeLeft) {
    if (timeLeft <= 0) return 'ç· ã‚åˆ‡ã‚Š';
    const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
    const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / 1000 * 60);
    const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
    let timeString = '';
    if (days > 0) timeString += `${days}æ—¥ `;
    if (hours > 0 || days > 0) timeString += `${String(hours).padStart(2,'0')}:`;
    timeString += `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
    return timeString;
  }
  function getJstDateString() {
    const now = new Date();
    const formatter = new Intl.DateTimeFormat('en-CA', {
      timeZone: 'Asia/Tokyo',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    });
    return formatter.format(now);
  }
  function getJstDateStringFromTimestamp(ts) {
    const d = new Date(ts);
    const formatter = new Intl.DateTimeFormat('en-CA', {
      timeZone: 'Asia/Tokyo',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    });
    return formatter.format(d);
  }

  function showToast(message) {
    const toast = document.createElement('div');
    toast.textContent = message;
    toast.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #333;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      z-index: 2000;
      opacity: 0;
      transition: opacity 0.5s, bottom 0.5s;
    `;
    document.body.appendChild(toast);
    setTimeout(() => {
      toast.style.opacity = '1';
      toast.style.bottom = '30px';
    }, 10);
    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.bottom = '20px';
      setTimeout(() => toast.remove(), 500);
    }, 4000);
  }

  async function unlockAchievement(userId, achievementId) {
    if (!ACHIEVEMENTS_MASTER[achievementId]) return;
    const userAchievementsRef = db.ref(`userAchievements/${userId}/achievements`);
    const snapshot = await userAchievementsRef.once('value');
    const myAchievements = snapshot.val() || {};

    if (!myAchievements[achievementId]) {
      await userAchievementsRef.child(achievementId).set(true);
      const achievement = ACHIEVEMENTS_MASTER[achievementId];
      showToast(`ğŸ† å®Ÿç¸¾ã‚’è§£é™¤ã—ã¾ã—ãŸï¼šã€${achievement.title}ã€‘`);
      
      const soundSettings = loadSoundSettings();
      if (soundSettings.enabled && audioContext && audioContext.state === 'running') {
          const sound = document.getElementById('notificationSound');
          sound.currentTime = 0;
          sound.play().catch(e => console.error("ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿã«å¤±æ•—:", e));
      }
      
      const updatedAchievements = { ...myAchievements, [achievementId]: true };
      const totalAchievements = Object.keys(ACHIEVEMENTS_MASTER).length - 1; 
      if (Object.keys(updatedAchievements).length >= totalAchievements) {
        await unlockAchievement(userId, 'puyuyu_hakase');
      }
    }
  }
  
  function getMomentumScore(thread) {
    let score = 0;
    const now = Date.now();
    const minutesSinceLastPost = (now - thread.lastUpdatedAt) / (1000 * 60);
    if (minutesSinceLastPost < 1) score += 50;
    else if (minutesSinceLastPost < 10) score += 20;
    else if (minutesSinceLastPost < 60) score += 5;
    const viewers = thread.viewerCount || 0;
    if (viewers >= 10) score += 40;
    else if (viewers >= 5) score += 20;
    else if (viewers >= 3) score += 10;
    return score;
  }

  function getMomentumEmoji(thread) {
    if (thread.tags && thread.tags.includes('ãƒ¬ãƒ™ãƒ«ä¸Šã’')) return '';
    const score = getMomentumScore(thread);
    if (score >= 70) return 'ğŸš€';
    if (score >= 40) return 'ğŸ”¥ğŸ”¥ğŸ”¥';
    if (score >= 20) return 'ğŸ”¥ğŸ”¥';
    if (score >= 1) return 'ğŸ”¥';
    return '';
  }

  function renderContent(s, post = null) {
      let content = escapeHTML(s);
      if(content.match(/javascript:/i)) return '[XSS Alert]';

      content = content.replace(/&gt;&gt;(\d+)/g, '<a href="#" data-action="quote" data-num="$1">&gt;&gt;$1</a>');
      
      const urlRegex = /(https?:\/\/[^\s<>"'()]+)/g;
      content = content.replace(urlRegex, (url) => {
          const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
          const twitterRegex = /https?:\/\/(?:twitter|x)\.com\/(?:\w+)\/status\/\d+/;
          const mediaRegex = /\.(?:jpg|jpeg|png|gif|webp|mp4|webm)$/i;

          const youtubeMatch = url.match(youtubeRegex);
          if (youtubeMatch) {
              return `<div class="embed-container"><iframe src="https://www.youtube.com/embed/${youtubeMatch[1]}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>`;
          }
          if (url.match(twitterRegex)) {
              return `<blockquote class="twitter-tweet" data-dnt="true"><a href="${url}">${url}</a></blockquote>`;
          }
          if (url.match(mediaRegex)) {
              if (url.toLowerCase().match(/\.(?:mp4|webm)$/)) {
                  return `<video src="${url}" controls class="embedded-video"></video>`;
              } else {
                  return `<img src="${url}" class="post-image" data-action="open-lightbox">`;
              }
          }
          return `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
      });

      let voteIndex = 0;
      const voteRegex = /\[vote\((\d+)\):([^\]]+)\]/g;
      content = content.replace(voteRegex, (match, p1, p2) => {
          const deadlineTimestamp = parseInt(p1, 10);
          const options = p2.split(',').map(opt => opt.trim());
          const isExpired = deadlineTimestamp > 0 && Date.now() > deadlineTimestamp;
          const voteId = post ? `vote-${post.id}-${voteIndex++}` : `vote-preview-${voteIndex++}`;
          const threadId = location.hash.startsWith('#thread-') ? location.hash.replace('#thread-', '') : null;
          if (!post || !threadId) {
              return `<div class="vote-box">${options.map(opt => `<button class="btn small" disabled>${escapeHTML(opt)}</button>`).join(' ')}</div>`;
          }
          const currentUser = getUser();
          const votes = post.votes || {};
          const myVote = votes[currentUser.permanentId];
          let voteCounts = {};
          options.forEach(opt => { voteCounts[opt] = 0; });
          Object.values(votes).forEach(votedOption => {
              if (voteCounts[votedOption] !== undefined) voteCounts[votedOption]++;
          });
          const totalVotes = Object.values(voteCounts).reduce((sum, count) => sum + count, 0);
          let headerHtml = '';
          if (isExpired) {
              headerHtml = `<div class="small-muted" style="margin-bottom:8px; text-align:center; font-weight:bold;">ã“ã®ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆã¯ç· ã‚åˆ‡ã‚‰ã‚Œã¾ã—ãŸ</div>`;
          } else if (deadlineTimestamp > 0) {
              const timeLeft = deadlineTimestamp - Date.now();
              const initialCountdownText = formatTimeLeft(timeLeft);
              headerHtml = `<div class="small-muted" style="margin-bottom:8px; text-align:center; font-weight:bold;">
                              <span>â° æŠ•ç¥¨çµ‚äº†ã¾ã§: </span>
                              <span class="vote-countdown" data-deadline="${deadlineTimestamp}">${initialCountdownText}</span>
                          </div>`;
          }
          const optionsHtml = options.map(opt => {
              const count = voteCounts[opt] || 0;
              const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
              const isVotedByUser = myVote === opt;
              const containerClass = `vote-option-bar-container ${isVotedByUser ? 'voted-by-user' : ''} ${isExpired ? 'expired' : ''}`;
              const dataAction = isExpired ? '' : `data-action="vote" data-thread-id="${threadId}" data-post-id="${post.id}" data-vote-option="${escapeHTML(opt)}"`;
              return `
                  <div class="${containerClass}" ${dataAction}>
                      <span class="vote-label">${escapeHTML(opt)}</span>
                      <div class="vote-bar-wrapper">
                          <div class="vote-option-bar" style="width: ${percentage}%;"></div>
                      </div>
                      <span class="vote-result">${count}ç¥¨ (${percentage.toFixed(1)}%)</span>
                  </div>
              `;
          }).join('');
          return `<div class="vote-box" id="${voteId}">${headerHtml}${optionsHtml}</div>`;
      });

      const diceResultRegex = /\[(\d+D\d+)=([\d\s]+)\s\(([\d,\s]+)\)\]/g;
      content = content.replace(diceResultRegex, (match, type, sum, rolls) => {
          if (rolls.includes(',')) {
              const highlightedRolls = rolls.replace(/(\d+)/g, `<span class="dice-result">$1</span>`);
              return `<span class="dice-result">${sum}</span> (${highlightedRolls})`;
          } else {
              return `<span class="dice-result">${sum}</span>`;
          }
      });
      return content.replace(/\n/g, '<br>');
  }
  
  function getUser() {
    const currentUser = auth.currentUser;
    if (!currentUser) {
        console.warn("èªè¨¼æœªå®Œäº†ã€‚ä¸€æ™‚çš„ãªæƒ…å ±ã‚’è¿”ã—ã¾ã™ã€‚");
        let permanentId = getCookie(PERMANENT_ID_COOKIE);
        if (!permanentId) {
            permanentId = uid(16);
            setCookie(PERMANENT_ID_COOKIE, permanentId, 365 * 10);
        }
        return { permanentId: "TEMP_ID", id: "TEMP_DAILY_ID", name: "èª­ã¿è¾¼ã¿ä¸­..." };
    }
    const permanentId = currentUser.uid;
    const todayStr = getJstDateString();
    let dailyInfo = {}; try { dailyInfo = JSON.parse(getCookie(DAILY_ID_COOKIE) || '{}'); } catch (e) {}
    if (dailyInfo.date !== todayStr || !dailyInfo.id) {
        dailyInfo = { id: uid(8), date: todayStr };
        setCookie(DAILY_ID_COOKIE, JSON.stringify(dailyInfo), 1);
    }
    let username = getCookie(USERNAME_COOKIE) || 'ãã®ã¸ã‚“ã®ãƒŸãƒ‹ãƒ¯ã‚¤ğŸ¥¹';
    return { permanentId, id: dailyInfo.id, name: username };
  }
  
  function getLevel(exp) {
    return (exp || 0) + 1;
  }

  function setUserName(n){
      if (n.length > NAME_LIMIT) {
        alert(`åå‰ã¯${NAME_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
        return false;
      }
      setCookie(USERNAME_COOKIE, n, 365);
      const history = loadNameHistory();
      const newHistory = history.filter(item => item.name !== n);
      newHistory.unshift({ name: n, changedAt: Date.now() });
      if (newHistory.length > 20) newHistory.pop();
      saveNameHistory(newHistory);
      refreshHeader();
      const newNameInput = document.getElementById('newName');
      if (newNameInput) newNameInput.value = n;
      const replyNameInput = document.getElementById('replyName');
      if (replyNameInput) replyNameInput.value = n;
      return true;
  }

  function refreshHeader(){document.getElementById('userDisplay').textContent=`ã‚ãªãŸ: ${getUser().name}`;}
  function loadHistory(){try{return JSON.parse(localStorage.getItem(HISTORY_KEY))||[];}catch(e){return[];}}
  function saveHistory(h){localStorage.setItem(HISTORY_KEY,JSON.stringify(h));}
  function addToHistory(id,title,lastUpdatedAt){let h=loadHistory();h=h.filter(i=>i.id!==id);h.unshift({id,title,lastUpdatedAt,visitedAt:Date.now()});if(h.length>50)h.pop();saveHistory(h);}
  function removeFromHistory(id){let h=loadHistory();h=h.filter(i=>i.id!==id);saveHistory(h);}
  window.goHome = () => {location.hash='';}

  function displayThreads(threadsToDisplay, sortMode = 'newPost', tagFilter = null, isReversed = false, page = 1, searchTerm = null) {
    const c = document.getElementById('threadListContainer'); 
    const p = document.getElementById('paginationContainer');
    if(!c || !p) return;
  
    const ngSettings = loadNgSettings();
    const hideWords = Object.keys(ngSettings).filter(word => ngSettings[word] === 'hide');
    const redWords = Object.keys(ngSettings).filter(word => ngSettings[word] === 'red');
  
    let displayableThreads = threadsToDisplay;
  
    if (sortMode === 'manyRes') {
        displayableThreads = displayableThreads.filter(t => t.postCounter < POST_LIMIT);
    }
    
    if (tagFilter) {
      displayableThreads = displayableThreads.filter(t => (t.tags || []).includes(tagFilter));
    }
    
    let sortedThreads = [...displayableThreads].sort((a, b) => {
      if (sortMode === 'newPost') return b.lastUpdatedAt - a.lastUpdatedAt;
      if (sortMode === 'newThread') return b.createdAt - a.createdAt;
      if (sortMode === 'manyRes') return (b.postCounter || 0) - (a.postCounter || 0);
      if (sortMode === 'momentum') {
        const scoreA = getMomentumScore(a);
        const scoreB = getMomentumScore(b);
        return scoreB - scoreA;
      }
      return 0;
    });
  
    if (isReversed) {
        sortedThreads.reverse();
    }
  
    const threadsAfterNgFilter = sortedThreads.filter(t => {
        const title = t.title || ''; 
        return !hideWords.some(word => title.toLowerCase().includes(word.toLowerCase()));
    });
    
    const totalPages = Math.max(1, Math.ceil(threadsAfterNgFilter.length / THREADS_PER_PAGE));
    currentPage = Math.min(page, totalPages);
    
    const startIndex = (currentPage - 1) * THREADS_PER_PAGE;
    const endIndex = startIndex + THREADS_PER_PAGE;
    const pagedThreads = threadsAfterNgFilter.slice(startIndex, endIndex);
  
    if(pagedThreads.length===0){
      c.innerHTML=`<div class="small-muted">${tagFilter ? `ã‚¿ã‚°ã€Œ${escapeHTML(tagFilter)}ã€ãŒä»˜ã„ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚` : 'è©²å½“ã™ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“'}</div>`;
      p.innerHTML = '';
    } else {
      c.innerHTML='';
      pagedThreads.forEach(t=>{
        const postCount = t.postCounter || 0;
        const momentumEmoji = getMomentumEmoji(t);
        const imgHtml = t.previewImg ? `<img src="${t.previewImg}" class="thread-preview-img" alt="preview">` : '';
        const tagsHtml = (t.tags || []).map(tag => `<a href="#" class="tag" data-tag="${escapeHTML(tag)}">${escapeHTML(tag)}</a>`).join('');
        
        const title = t.title || '';
        const titleContainsRedWord = redWords.some(word => title.toLowerCase().includes(word.toLowerCase()));
        const titleClass = titleContainsRedWord ? 'thread-link ng-word-red' : 'thread-link';
        
        let displayTitle = escapeHTML(title.replace(/#[\p{L}\p{N}_]+/ug, '').replace(/(\r\n|\n|\r)/gm, "").trim());
  
        const lockIcon = t.levelRestriction > 0 ? 'ğŸ”’' : '';
  
        if (searchTerm && searchTerm.trim() !== '') {
          try {
            const regex = new RegExp(escapeHTML(searchTerm.trim()).replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            displayTitle = displayTitle.replace(regex, `<span class="search-highlight">$&</span>`);
          } catch (e) { /* Invalid regex, do nothing */ }
        }
  
        const i=document.createElement('div');
        i.className='thread-item';
        i.innerHTML=`
          ${imgHtml}
          <div class="thread-info">
            <div class="thread-title-wrapper">
              <a class="${titleClass}" href="#thread-${t.id}">${lockIcon}${displayTitle}</a>
            </div>
            <div class="thread-tags">${tagsHtml}</div>
          </div>
          <div class="thread-meta-info">
            <div class="meta">${postCount}ãƒ¬ã‚¹</div>
            <div class="meta">${momentumEmoji}</div>
          </div>`;
        c.appendChild(i);
      });
      document.querySelectorAll('.tag').forEach(tagEl => {
        tagEl.onclick = (e) => {
            e.preventDefault();
            const tag = e.target.dataset.tag;
            document.getElementById('searchInput').value = `#${tag}`;
            document.getElementById('searchBtn').click();
        };
      });
  
      p.innerHTML = `
        <div class="pagination-controls">
          <button id="prevPageBtn" class="btn small" ${currentPage === 1 ? 'disabled' : ''}>å‰ã¸</button>
          <span class="small-muted">${currentPage} / ${totalPages} ãƒšãƒ¼ã‚¸</span>
          <button id="nextPageBtn" class="btn small" ${currentPage === totalPages ? 'disabled' : ''}>æ¬¡ã¸</button>
        </div>
      `;
      document.getElementById('prevPageBtn').onclick = () => { if(currentPage > 1) { currentPage--; window.performDisplay(); } };
      document.getElementById('nextPageBtn').onclick = () => { if(currentPage < totalPages) { currentPage++; window.performDisplay(); } };
    }
  }

  // â˜…â˜…â˜… [å¤‰æ›´ç‚¹] getWeatheré–¢æ•°ã‚’ç¬¬2ä¸–ä»£ã®å‘¼ã³å‡ºã—æ–¹ã«å¤‰æ›´ â˜…â˜…â˜…
  async function getOkachimachiWeather() {
    try {
        const getWeather = functions.httpsCallable('getWeather');
        const result = await getWeather();
        const data = result.data;

        const weatherDescription = data.weather[0]?.description || 'ä¸æ˜';
        const weatherIcon = ((icon) => {
            const map = {
            '01d': 'â˜€ï¸', '01n': 'ğŸŒ™', '02d': 'ğŸŒ¤ï¸', '02n': 'â˜ï¸',
            '03d': 'â˜ï¸', '03n': 'â˜ï¸', '04d': 'â˜ï¸', '04n': 'â˜ï¸',
            '09d': 'ğŸŒ§ï¸', '09n': 'ğŸŒ§ï¸', '10d': 'ğŸŒ¦ï¸', '10n': 'ğŸŒ§ï¸',
            '11d': 'â›ˆï¸', '11n': 'â›ˆï¸', '13d': 'â„ï¸', '13n': 'â„ï¸',
            '50d': 'ğŸŒ«ï¸', '50n': 'ğŸŒ«ï¸'
            };
            return map[icon] || '';
        })(data.weather[0]?.icon);
        
        const temp = data.main?.temp?.toFixed(1) || 'N/A';
        const humidity = data.main?.humidity || 'N/A';
        const windSpeed = data.wind?.speed?.toFixed(1) || 'N/A';

        return `ã€ç¾åœ¨ã®å¾¡å¾’ç”ºã®å¤©æ°—æƒ…å ±ã€‘
å¤©æ°—: ${weatherDescription} ${weatherIcon}
æ°—æ¸©: ${temp}â„ƒ
æ¹¿åº¦: ${humidity}%
é¢¨é€Ÿ: ${windSpeed} m/s
--------------------
`;
    } catch (error) {
        console.error("å¤©æ°—æƒ…å ±ã®å–å¾—ã‚¨ãƒ©ãƒ¼:", error);
        return 'ã€å¤©æ°—æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‘\n';
    }
  }

  function renderHome() {
    currentPage = 1; 
    document.getElementById('app').innerHTML = `<div class="card"><h2>ã‚¹ãƒ¬ãƒƒãƒ‰ä¸€è¦§</h2><div class="search-box"><input type="text" id="searchInput" placeholder="ã‚¿ã‚¤ãƒˆãƒ«æ¤œç´¢ or #ã‚¿ã‚°å"><button id="searchBtn" class="btn small">æ¤œç´¢</button><button id="clearSearchBtn" class="btn small">ã‚¯ãƒªã‚¢</button></div><div class="sort-box"><span class="small-muted">ä¸¦ã³æ›¿ãˆ:</span><select id="sortSelect"><option value="newPost" selected>æ–°ç€ãƒ¬ã‚¹é †</option><option value="newThread">ã‚¹ãƒ¬ç«‹ã¦é †</option><option value="manyRes">ãƒ¬ã‚¹æ•°é †</option><option value="momentum">å‹¢ã„é †</option></select><label for="sortReverseCheckbox" class="small-muted" style="display:flex;align-items:center;gap:4px;"><input type="checkbox" id="sortReverseCheckbox">é€†é †</label></div><div id="threadListContainer"></div><div id="paginationContainer"></div></div>`;
    const threadListContainer = document.getElementById('threadListContainer');
    startLoadingAnimation(threadListContainer, 'ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èª­ã¿è¾¼ã¿ä¸­');
    const sortSelect = document.getElementById('sortSelect');
    const searchInput = document.getElementById('searchInput');
    const reverseCheckbox = document.getElementById('sortReverseCheckbox');
    
    window.performDisplay = () => {
        stopLoadingAnimation();
        const sortMode = sortSelect.value;
        const searchTerm = searchInput.value.trim();
        const isReversed = reverseCheckbox.checked;

        let sourceThreads;
        let filteredThreads;
        
        const activeThreads = allThreads.filter(t => !t.isArchived && !t.isHallOfFame);

        if (searchTerm.toLowerCase() === '#ãƒ¬ãƒ™ãƒ«ä¸Šã’') {
            sourceThreads = allThreads;
            const tag = searchTerm.substring(1);
            filteredThreads = sourceThreads.filter(t => (t.tags || []).includes(tag));
            displayThreads(filteredThreads, sortMode, tag, isReversed, currentPage, null);

        } else if (searchTerm.startsWith('#')) {
            sourceThreads = activeThreads.filter(t => !(t.tags || []).includes('ãƒ¬ãƒ™ãƒ«ä¸Šã’'));
            const tag = searchTerm.substring(1);
            filteredThreads = sourceThreads.filter(t => (t.tags || []).includes(tag));
            displayThreads(filteredThreads, sortMode, tag, isReversed, currentPage, null);

        } else {
            sourceThreads = activeThreads.filter(t => !(t.tags || []).includes('ãƒ¬ãƒ™ãƒ«ä¸Šã’'));
            filteredThreads = searchTerm ? sourceThreads.filter(t => (t.title || '').toLowerCase().includes(searchTerm.toLowerCase())) : sourceThreads;
            displayThreads(filteredThreads, sortMode, null, isReversed, currentPage, searchTerm);
        }
    }

    sortSelect.onchange = () => { currentPage = 1; performDisplay(); };
    reverseCheckbox.onchange = performDisplay;
    document.getElementById('searchBtn').onclick = () => { currentPage = 1; performDisplay(); };
    document.getElementById('clearSearchBtn').onclick=()=>{ searchInput.value=''; currentPage = 1; performDisplay(); };
    searchInput.onkeydown=(e)=>{if(e.key==='Enter') { currentPage = 1; performDisplay(); }};
  }
  
  // â˜…â˜…â˜… [æœ€çµ‚ç‰ˆ] å±¥æ­´ãƒšãƒ¼ã‚¸æç”»é–¢æ•° â˜…â˜…â˜…
  async function renderHistoryPage() {
    document.getElementById('app').innerHTML = `
      <div class="card">
        <h2>ğŸ”” é€šçŸ¥ä¸€è¦§</h2>
        <div id="notificationsListContainer"></div>
      </div>
      <div class="card">
        <h2>ğŸ“œ é–²è¦§å±¥æ­´</h2>
        <div id="historyListContainer"></div>
      </div>`;
    
    const nC = document.getElementById('notificationsListContainer');
    const hC = document.getElementById('historyListContainer');
    
    const unreadNotifications = Object.entries(globalUnreadNotifications)
      .filter(([id, notif]) => notif && !notif.read)
      .sort(([idA, a], [idB, b]) => b.timestamp - a.timestamp);

    if (unreadNotifications.length > 0) {
        nC.innerHTML = unreadNotifications.map(([id, notif]) => {
            if (notif.type === 'ACHIEVEMENT') {
                return `
                <div class="history-item">
                    <div class="thread-info">
                        <a class="thread-link" href="#thread-${notif.threadId}" data-notification-id="${id}">
                          ğŸ† å®Ÿç¸¾è§£é™¤ï¼š${escapeHTML(notif.title)}
                        </a>
                        <div class="small-muted" style="margin-top:4px;">${escapeHTML(notif.text)}</div>
                    </div>
                    <div class="thread-meta-info">
                        <div class="small-muted">${formatTimestamp(notif.timestamp)}</div>
                    </div>
                </div>`;
            } else { // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å®‰ä¾¡é€šçŸ¥
                return `
                <div class="history-item">
                    <div class="thread-info">
                        <a class="thread-link" href="#thread-${notif.threadId}" data-notification-id="${id}">
                          ã€Œ${escapeHTML(notif.fromUserName)}ã€ã•ã‚“ã‹ã‚‰è¿”ä¿¡
                        </a>
                        <div class="small-muted" style="margin-top:4px;">
                          ã‚¹ãƒ¬ï¼š${escapeHTML(notif.threadTitle)}
                        </div>
                        <div class="body" style="font-size: 13px; margin-top: 4px; padding-left: 8px; border-left: 2px solid var(--border-color);">
                          ${escapeHTML(notif.postTextSnippet)}...
                        </div>
                    </div>
                    <div class="thread-meta-info">
                        <div class="small-muted">${formatTimestamp(notif.timestamp)}</div>
                    </div>
                </div>`;
            }
        }).join('');
    } else {
        nC.innerHTML = '<div class="small-muted">æ–°ã—ã„é€šçŸ¥ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</div>';
    }

    startLoadingAnimation(hC, 'å±¥æ­´ã‚’èª­ã¿è¾¼ã¿ä¸­');
    
    const history = loadHistory();
    if (history.length === 0) {
        stopLoadingAnimation();
        hC.innerHTML = '<div class="small-muted">ã¾ã é–²è¦§å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</div>';
        return;
    }

    try {
        const metaSnapshot = await db.ref('threadMetadata').once('value');
        const allMeta = metaSnapshot.val() || {};
        
        stopLoadingAnimation();
        const historyHtml = history.map(item => {
            const meta = allMeta[item.id];
            if (!meta || meta.isArchived) return '';
            return `
                <div class="history-item">
                    <div class="thread-info">
                        <a class="thread-link" href="#thread-${item.id}">${escapeHTML(item.title)}</a>
                        <span class="history-item-res-count meta">(${meta.postCounter || 0}ãƒ¬ã‚¹)</span>
                    </div>
                    <div class="thread-meta-info">
                        <div class="small-muted">${formatTimestamp(item.visitedAt)}</div>
                    </div>
                </div>`;
        }).join('');
        
        hC.innerHTML = historyHtml || '<div class="small-muted">æœ‰åŠ¹ãªé–²è¦§å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</div>';

    } catch (e) {
        console.error("å±¥æ­´ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—:", e);
        stopLoadingAnimation();
        hC.innerHTML = '<div class="banned-note">å±¥æ­´ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</div>';
    }
  }

  async function renderMemoriesPage() {
    document.getElementById('app').innerHTML = `<div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
            <h2>æ®¿å ‚å…¥ã‚ŠğŸ‘‘ã‚¹ãƒ¬ä¸€è¦§</h2>
            <div>
                <a href="#" class="btn small">ğŸ  é›†ä¼šæ‰€ã«æˆ»ã‚‹</a>
            </div>
        </div>
        <div id="memoriesListContainer"></div>
    </div>`;

    document.querySelector('a[href="#"]').onclick = (e) => { e.preventDefault(); goHome(); };

    const container = document.getElementById('memoriesListContainer');
    startLoadingAnimation(container);

    try {
        const metaRef = db.ref('threadMetadata').orderByChild('isHallOfFame').equalTo(true);
        const snapshot = await metaRef.once('value');
        stopLoadingAnimation();

        if (!snapshot.exists()) {
            container.innerHTML = '<div class="small-muted">ã¾ã æ®¿å ‚å…¥ã‚Šã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</div>';
            return;
        }

        const hallOfFameThreads = Object.values(snapshot.val()).sort((a, b) => b.lastUpdatedAt - a.lastUpdatedAt);
        
        container.innerHTML = '';
        hallOfFameThreads.forEach(t => {
            const i=document.createElement('div');
            i.className='thread-item';
            i.innerHTML=`
              <div class="thread-info">
                <a class="thread-link" href="#thread-${t.id}">${escapeHTML(t.title)}</a>
              </div>
              <div class="thread-meta-info">
                <div class="meta">${t.postCounter}ãƒ¬ã‚¹</div>
                <div class="meta small-muted">${formatTimestamp(t.lastUpdatedAt)}</div>
              </div>`;
            container.appendChild(i);
        });

    } catch (error) {
        stopLoadingAnimation();
        container.innerHTML = `<div class="banned-note">æ®¿å ‚å…¥ã‚Šã‚¹ãƒ¬ãƒƒãƒ‰ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}</div>`;
    }
  }

function renderTermsPage() {
    document.getElementById('app').innerHTML = `<div class="card">
      <h2>åˆ©ç”¨è¦ç´„ / ã“ã®ã‚µã‚¤ãƒˆã«ã¤ã„ã¦</h2>
      <p style="font-weight: bold;">å½“ã‚µã‚¤ãƒˆã¯ã€ç®¡ç†äººï¼ˆpuyuyuï¼‰ãŒå€‹äººçš„ãªè¶£å‘³ã§é–‹ç™ºãƒ»é‹å–¶ã™ã‚‹ãƒ•ã‚¡ãƒ³ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã§ã™ã€‚</p>
      <p><strong>å–¶åˆ©ã‚’ä¸»ç›®çš„ã¨ã—ãŸã‚µã‚¤ãƒˆã§ã¯æ–­ã˜ã¦ã‚ã‚Šã¾ã›ã‚“ã€‚</strong></p>
      <p>ã‚µã‚¤ãƒˆå†…ã«è¡¨ç¤ºã•ã‚Œã‚‹åºƒå‘Šã¯ã€ã‚µãƒ¼ãƒãƒ¼è²»ç”¨ã‚„ãƒ‰ãƒ¡ã‚¤ãƒ³ç¶­æŒè²»ãªã©ã€ã‚µã‚¤ãƒˆã®é‹å–¶ã‚’ç¶™ç¶šã™ã‚‹ãŸã‚ã«å¿…è¦ãªæœ€ä½é™ã®çµŒè²»ã‚’è³„ã†ãŸã‚ã«è¨­ç½®ã—ã¦ãŠã‚Šã¾ã™ã€‚</p>
      <p style="margin-top: 24px;">ã™ã¹ã¦ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¿«é©ã«åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã€ã”å”åŠ›ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚</p>
      <button id="goHomeFromTermsBtn" class="btn">ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹</button>
    </div>`;
    document.getElementById('goHomeFromTermsBtn').onclick = goHome;
  }

  async function renderSettingsPage() {
    cleanupListeners();
    const user = getUser();
    myTotalExp = (await db.ref(`userLevels/${user.permanentId}/exp`).once('value')).val() || 0;
    const userLevel = getLevel(myTotalExp);
    
    if (userLevel >= 10000) await unlockAchievement(user.permanentId, 'matsumoto_san');
    if (userLevel >= 1000) await unlockAchievement(user.permanentId, 'saikyo_ode');
    if (userLevel >= 60) await unlockAchievement(user.permanentId, 'yumechan');
    if (userLevel >= 30) await unlockAchievement(user.permanentId, 'teriri');
    if (userLevel >= 10) await unlockAchievement(user.permanentId, 'puyuyu');
    if (userLevel >= 5) await unlockAchievement(user.permanentId, 'mini_wai');
    
    const achievementsSnapshot = await db.ref(`userAchievements/${user.permanentId}`).once('value');
    const myAchievements = achievementsSnapshot.val() || { achievements: {}, equippedAchievement: null };
    const unlockedAchievements = myAchievements.achievements ? Object.keys(myAchievements.achievements) : [];
    const soundSettings = loadSoundSettings();
    document.getElementById('app').innerHTML = `
      <div class="card">
        <h2>ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«è¨­å®š</h2>
        <div style="display:flex; gap:8px; margin-bottom:12px;">
          <input type="text" id="settingsNameInput" value="${escapeHTML(user.name)}" placeholder="æ–°ã—ã„åå‰">
          <button id="settingsSaveNameBtn" class="btn small">å¤‰æ›´</button>
        </div>
        <div style="margin-bottom:12px;">
          <label for="titleSelect" class="small-muted">ç§°å·è¨­å®š:</label>
          <select id="titleSelect" style="width:100%;"></select>
        </div>
        <div style="font-size:13px; display:flex; flex-direction:column; gap:8px;">
          <div style="font-weight:bold;">ã‚ãªãŸã®ãƒ¬ãƒ™ãƒ«: Lv. ${userLevel}</div>
          <div style="display:flex; align-items:center; gap:8px;">
            <span>Permanent ID: ${user.permanentId}</span>
            <button class="btn small" data-copy-text="${user.permanentId}">ã‚³ãƒ”ãƒ¼</button>
          </div>
          <div style="display:flex; align-items:center; gap:8px;">
            <span>Daily ID: ${user.id}</span>
            <button class="btn small" data-copy-text="${user.id}">ã‚³ãƒ”ãƒ¼</button>
          </div>
        </div>
      </div>
      <div class="card">
        <h2>å®Ÿç¸¾ä¸€è¦§</h2>
        <div id="achievementsListContainer"></div>
      </div>
      <div class="card">
        <h2>é€šçŸ¥è¨­å®š</h2>
        <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
            <input type="checkbox" id="soundToggleCheckbox" ${soundSettings.enabled ? 'checked' : ''}>
            <span>è‡ªåˆ†å®›ã¦ã®ãƒ¬ã‚¹ãŒã‚ã£ãŸæ™‚ã«é€šçŸ¥éŸ³ã‚’é³´ã‚‰ã™</span>
        </label>
      </div>
      <div class="card">
        <h2>åå‰å¤‰æ›´å±¥æ­´</h2>
        <div id="nameHistoryContainer" style="font-size:13px;"></div>
      </div>
      <div class="card">
        <h2>è‡ªåˆ†ã®æŠ•ç¨¿ã‚’æ¤œç´¢</h2>
        <div class="search-box">
          <input type="text" id="myPostSearchInput" placeholder="ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢">
          <button id="myPostSearchBtn" class="btn small">æ¤œç´¢</button>
        </div>
        <div id="myPostSearchResults"></div>
      </div>
      <div class="card">
        <h2>NGãƒ¯ãƒ¼ãƒ‰è¨­å®š</h2>
        <div style="display:flex; gap:8px; margin-bottom:12px;">
          <input type="text" id="ngWordInput" placeholder="NGãƒ¯ãƒ¼ãƒ‰" style="flex-grow:1;">
          <select id="ngActionSelect">
            <option value="hide">æŠ•ç¨¿ã‚’éè¡¨ç¤º</option>
            <option value="red">å˜èªã‚’èµ¤æ–‡å­—</option>
          </select>
          <button id="addNgWordBtn" class="btn small">è¿½åŠ </button>
        </div>
        <div id="ngWordsListContainer"></div>
      </div>
    `;

    const titleSelect = document.getElementById('titleSelect');
    const noTitleOption = document.createElement('option');
    noTitleOption.value = "none";
    noTitleOption.textContent = "ç§°å·ãªã—";
    titleSelect.appendChild(noTitleOption);

    unlockedAchievements.forEach(achId => {
        if (ACHIEVEMENTS_MASTER[achId]) {
            const option = document.createElement('option');
            option.value = achId;
            option.textContent = ACHIEVEMENTS_MASTER[achId].title;
            titleSelect.appendChild(option);
        }
    });
    titleSelect.value = myAchievements.equippedAchievement || "none";

    titleSelect.onchange = async () => {
        const selectedTitleId = titleSelect.value;
        try {
            const valueToSet = selectedTitleId === "none" ? null : selectedTitleId;
            await db.ref(`userAchievements/${user.permanentId}/equippedAchievement`).set(valueToSet);
            showToast('ç§°å·ã‚’å¤‰æ›´ã—ã¾ã—ãŸï¼');
        } catch (e) {
            alert('ç§°å·ã®å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        }
    };
    
    const achievementsListContainer = document.getElementById('achievementsListContainer');
    Object.keys(ACHIEVEMENTS_MASTER).forEach(achId => {
        const achData = ACHIEVEMENTS_MASTER[achId];
        const isUnlocked = unlockedAchievements.includes(achId);
        const item = document.createElement('div');
        item.className = 'achievement-item';
        item.innerHTML = `
            <div class="achievement-info">
                <div class="achievement-title">${achData.title}</div>
                <div class="achievement-desc">${achData.description}</div>
            </div>
            <span class="achievement-status ${isUnlocked ? 'status-unlocked' : 'status-locked'}">${isUnlocked ? 'ç²å¾—æ¸ˆã¿' : 'æœªç²å¾—'}</span>
        `;
        achievementsListContainer.appendChild(item);
    });

    document.getElementById('settingsSaveNameBtn').onclick = () => {
      const newName = document.getElementById('settingsNameInput').value.trim();
      if(newName && !containsNGWord(newName)) {
        if(setUserName(newName)) {
          alert('åå‰ã‚’å¤‰æ›´ã—ã¾ã—ãŸã€‚');
          renderSettingsPage();
        }
      } else {
        alert('åå‰ãŒç©ºã‹ã€ä¸é©åˆ‡ãªå˜èªãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚');
      }
    };
    document.querySelectorAll('[data-copy-text]').forEach(btn => {
      btn.onclick = (e) => {
        navigator.clipboard.writeText(e.target.dataset.copyText).then(() => {
          const originalText = e.target.textContent;
          e.target.textContent = 'OK!';
          setTimeout(() => { e.target.textContent = originalText; }, 1000);
        });
      };
    });
    document.getElementById('soundToggleCheckbox').onchange = (e) => {
        saveSoundSettings({ enabled: e.target.checked });
    };
    const nameHistoryContainer = document.getElementById('nameHistoryContainer');
    const nameHistory = loadNameHistory();
    nameHistoryContainer.innerHTML = nameHistory.length > 0
      ? nameHistory.map(h => `<div><span class="small-muted">${formatTimestamp(h.changedAt)}</span> â†’ <b>${escapeHTML(h.name)}</b></div>`).join('')
      : '<div class="small-muted">å¤‰æ›´å±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</div>';
    
    document.getElementById('myPostSearchBtn').onclick = () => {
        const keyword = document.getElementById('myPostSearchInput').value.trim();
        const resultsContainer = document.getElementById('myPostSearchResults');
        if (!keyword) {
            resultsContainer.innerHTML = '<div class="small-muted">ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚</div>';
            return;
        }
        if (searchWorker) {
            searchWorker.terminate();
        }
        startLoadingAnimation(resultsContainer, 'ã‚ãªãŸã®æŠ•ç¨¿ã‚’æ¤œç´¢ä¸­');
        const workerScript = `
            let db;
            self.onmessage = async (e) => {
                const { command, firebaseConfig, history, userId, keyword } = e.data;
                if (command === 'initialize') {
                    importScripts("https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js");
                    importScripts("https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js");
                    try {
                        if (!firebase.apps.length) {
                           firebase.initializeApp(firebaseConfig);
                        }
                        db = firebase.database();
                        self.postMessage({ status: 'initialized' });
                    } catch (err) {
                        self.postMessage({ status: 'error', message: err.message });
                    }
                } else if (command === 'search') {
                    try {
                        const results = [];
                        const totalThreads = history.length;
                        for (let i = 0; i < totalThreads; i++) {
                            const threadInfo = history[i];
                            const postsSnapshot = await db.ref('threads/' + threadInfo.id + '/posts').once('value');
                            if (postsSnapshot.exists()) {
                                const posts = postsSnapshot.val();
                                for (const postId in posts) {
                                    const post = posts[postId];
                                    if (post.author && post.author.permanentId === userId && post.text && post.text.toLowerCase().includes(keyword.toLowerCase())) {
                                        results.push({ thread: threadInfo, post });
                                    }
                                }
                            }
                            self.postMessage({ status: 'progress', progress: Math.round(((i + 1) / totalThreads) * 100) });
                        }
                        self.postMessage({ status: 'complete', results });
                    } catch (err) {
                        self.postMessage({ status: 'error', message: err.message });
                    }
                }
            };
        `;
        searchWorker = new Worker(URL.createObjectURL(new Blob([workerScript])));
        
        searchWorker.onmessage = (e) => {
            const { status, message, progress, results } = e.data;
            if (status === 'initialized') {
                searchWorker.postMessage({ command: 'search', history: loadHistory(), userId: getUser().permanentId, keyword });
            } else if (status === 'progress') {
                const textSpan = resultsContainer.querySelector('span');
                if(textSpan) textSpan.textContent = `ã‚ãªãŸã®æŠ•ç¨¿ã‚’æ¤œç´¢ä¸­â€¦ ${progress}%`;
            } else if (status === 'complete') {
                stopLoadingAnimation();
                resultsContainer.innerHTML = results.length > 0
                  ? results.sort((a,b) => b.post.createdAt - a.post.createdAt).map(item => `
                    <div style="border-top:1px solid var(--border-color); padding: 8px 0;">
                      <div class="small-muted">ã‚¹ãƒ¬: <a href="#thread-${item.thread.id}">${escapeHTML(item.thread.title)}</a> (${formatTimestamp(item.post.createdAt)})</div>
                      <div class="body">${renderContent(item.post.text)}</div>
                    </div>`).join('')
                  : `<div class="small-muted">ã€Œ${escapeHTML(keyword)}ã€ã«ä¸€è‡´ã™ã‚‹æŠ•ç¨¿ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚</div>`;
                
                searchWorker.terminate();
                searchWorker = null;
            } else if (status === 'error') {
                stopLoadingAnimation();
                resultsContainer.innerHTML = `<div class="banned-note">æ¤œç´¢ã«å¤±æ•—ã—ã¾ã—ãŸ: ${message}</div>`;
                searchWorker.terminate();
                searchWorker = null;
            }
        };
        searchWorker.postMessage({ command: 'initialize', firebaseConfig });
    };

    const ngWordInput = document.getElementById('ngWordInput');
    const ngActionSelect = document.getElementById('ngActionSelect');
    const addNgWordBtn = document.getElementById('addNgWordBtn');
    const ngWordsListContainer = document.getElementById('ngWordsListContainer');
    function renderNgList() {
      const settings = loadNgSettings();
      const words = Object.keys(settings);
      ngWordsListContainer.innerHTML = words.length > 0
        ? words.map(word => `
          <div style="display:flex; align-items:center; gap:8px; font-size:13px; padding: 4px 0;">
            <span style="flex-grow:1;"><b>${escapeHTML(word)}</b> â†’ <span class="small-muted">${settings[word] === 'hide' ? 'éè¡¨ç¤º' : 'èµ¤æ–‡å­—'}</span></span>
            <button class="btn small warn" data-ng-word="${escapeHTML(word)}">å‰Šé™¤</button>
          </div>`).join('')
        : '<div class="small-muted">NGãƒ¯ãƒ¼ãƒ‰ã¯è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</div>';
      ngWordsListContainer.querySelectorAll('[data-ng-word]').forEach(btn => {
        btn.onclick = (e) => {
          const wordToDelete = e.target.dataset.ngWord;
          const currentSettings = loadNgSettings();
          delete currentSettings[wordToDelete];
          saveNgSettings(currentSettings);
          renderNgList();
        };
      });
    }
    addNgWordBtn.onclick = () => {
      const word = ngWordInput.value.trim();
      if (word) {
        const settings = loadNgSettings();
        settings[word] = ngActionSelect.value;
        saveNgSettings(settings);
        ngWordInput.value = '';
        renderNgList();
      }
    };
    renderNgList();
  }
  
  function generatePostHtml(post, idx, t, anchorCounts) {
    const u = getUser(), o = t.op && t.op.permanentId === u.permanentId, isAdm = ADMIN_IDS.includes(u.permanentId);
    
    const authorId = post.author.permanentId;
    const exp = (userLevelsCache[authorId] && userLevelsCache[authorId].exp) || 0;
    const l = getLevel(exp);
    
    const authorAchievements = userAchievementsCache[authorId];
    let titleText;
    const equipped = authorAchievements ? authorAchievements.equippedAchievement : null;
    if (equipped && ACHIEVEMENTS_MASTER[equipped]) {
        titleText = ACHIEVEMENTS_MASTER[equipped].title;
    } else {
        titleText = `Lv. ${l}`;
    }

    const b=t.banned&&t.banned[authorId],gb=globalBanList[authorId];
    const reacs=post.reactions||{};
    const mR=reacs[u.permanentId];
    
    let aH=`<b class="post-author" data-action="show-profile" data-name="${escapeHTML(post.author.name)}" data-id="${authorId}" data-isopadm="${o||isAdm}" data-daily-id="${post.author.id}" data-post-timestamp="${post.createdAt}" data-thread-id="${t.id}">${escapeHTML(post.author.name)}</b> <span class="badge-level" title="Lv.${l}">${titleText}</span>`;
    if(authorId===t.op.permanentId) aH+=` <span class="badge-op">ä¸»</span>`;
    if(anchorCounts[post.id]) { aH += ` <span class="badge-anchor" data-action="show-anchors" data-thread-id="${t.id}" data-post-id="${post.id}">${anchorCounts[post.id]}</span>`; }
    
    const rC={}; BASE_REACTIONS.forEach(r=>rC[r]=0);
    Object.values(reacs).forEach(reac=>{if(rC[reac]!==undefined)rC[reac]++;});
    
    let ctlH=BASE_REACTIONS.map(bR=>{
      const count=rC[bR];
      const iMR=mR===bR;
      const dR=iMR?REACTION_PAIRS[bR]:bR;
      return`<button class="btn small ${iMR?'liked':''}" data-action="react" data-thread-id="${t.id}" data-post-id="${post.id}" data-reac="${bR}">${dR} ${count}</button>`;
    }).join(' ');

    if(u.permanentId===authorId||o||isAdm) ctlH+=` <button class="btn small warn" data-action="delete-post" data-thread-id="${t.id}" data-post-id="${post.id}">å‰Šé™¤</button>`;
    if(u.permanentId===authorId) ctlH+=` <button class="btn small" data-action="edit-post" data-thread-id="${t.id}" data-post-id="${post.id}">ç·¨é›†</button>`;
    
    const ngSettings = loadNgSettings();
    const ngWords = Object.keys(ngSettings);
    let pB=post.deleted?`<div class="deleted-note">[å‰Šé™¤ã•ã‚Œã¾ã—ãŸ]</div>`:`<div class="body">${renderContent(post.text,post)}</div>${post.img?`<img src="${post.img}" class="post-image" data-action="open-lightbox">`:''}`;
    if (!post.deleted) {
      let isHidden = false;
      let processedText = renderContent(post.text, post);
      for (const word of ngWords) {
        if (post.text.toLowerCase().includes(word.toLowerCase())) {
          if (ngSettings[word] === 'hide') {
            pB = `<div class="ng-hidden-post">[NGãƒ¯ãƒ¼ãƒ‰ã«ä¸€è‡´ã—ãŸãŸã‚éè¡¨ç¤º]</div>`; isHidden = true; break; 
          } else if (ngSettings[word] === 'red') {
            const regex = new RegExp(escapeHTML(word), 'gi');
            processedText = processedText.replace(regex, `<span class="ng-word-red">${escapeHTML(word)}</span>`);
          }
        }
      }
      if (!isHidden) { pB = `<div class="body">${processedText}</div>${post.img?`<img src="${post.img}" class="post-image" data-action="open-lightbox">`:''}`; }
    }
    const mainContent = b||gb ? `<div class="banned-note">${gb?'[ã“ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯BANã•ã‚Œã¦ã„ã¾ã™]':'[ã“ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã“ã®ã‚¹ãƒ¬ã§ã‚¢ã‚¯ç¦ã•ã‚Œã¦ã„ã¾ã™]'}</div>` : `${pB}<div class="controls">${ctlH}<span class="timestamp small-muted">${formatTimestamp(post.createdAt)}</span></div>`;
    
    const effectAttr = post.effect ? `data-effect="${post.effect}"` : '';
    return `<div class="post" data-post-id="${post.id}" ${effectAttr}><div class="meta"><span class="no" data-action="insert-quote-number" data-num="${idx}">No.${idx}</span>${aH}</div>${mainContent}</div>`;
  }

  function fullRenderThreadView(id, t) {
    const u = getUser(), o = t.op && t.op.permanentId === u.permanentId, isAdm = ADMIN_IDS.includes(u.permanentId);
    let deleteBtnHtml = (o || isAdm) ? `<button class="btn small warn" data-action="delete-thread" data-thread-id="${id}" style="margin-left:auto;">ã‚¹ãƒ¬ãƒƒãƒ‰å‰Šé™¤</button>` : '';
    const posts = Object.values(t.posts || {}).sort((a, b) => a.createdAt - b.createdAt);
    const pC = posts.length;
    let rF = '';
    if (pC >= POST_LIMIT) {
        const hallOfFameMessage = `<div class="banned-note" style="text-align:center;padding:10px;">ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯${POST_LIMIT}ãƒ¬ã‚¹ã«é”ã—ã€æ®¿å ‚å…¥ã‚Šã—ã¾ã—ãŸã€‚</div>`;
        rF = (o) ? `<div style="text-align:center; padding:10px;"><button class="btn" onclick="window.prepareNextThread('${id}')">æ¬¡ã‚¹ãƒ¬ã‚’ä½œæˆ</button></div>${hallOfFameMessage}` : hallOfFameMessage;
    } else {
        rF = `<h4>ãƒ¬ã‚¹æŠ•ç¨¿</h4><input id="replyName" type="text" placeholder="åå‰" value="${escapeHTML(u.name)}" style="margin-bottom:8px;"><small class="small-muted" style="display:block;margin-top:-6px;margin-bottom:8px;">åå‰æ¬„ã« sage ã¨å…¥åŠ›ã™ã‚‹ã¨ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒˆãƒƒãƒ—ã«ä¸ŠãŒã‚‰ãªããªã‚Šã¾ã™ã€‚</small><textarea id="replyText" placeholder="æœ¬æ–‡"></textarea><div class="controls" style="justify-content:flex-start; margin-top:8px; gap:8px;"><button id="createVoteBtn" class="btn small">ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆä½œæˆ</button><button id="createDrawBtn" class="btn small">ğŸ¨ ãŠçµµæã</button></div><div style="margin-top:8px; display:flex; justify-content:space-between; align-items:center;"><div id="replyImageContainer"><input id="replyImage" type="file" accept="image/*"></div><button class="btn" id="replyBtn">æŠ•ç¨¿</button></div>`;
    }
    const anchorCounts = {};
    posts.forEach((p, postIndex) => {
        if (p.text) {
            const anchors = p.text.match(/>>(\d+)/g) || [];
            anchors.forEach(anchor => {
                const postNum = parseInt(anchor.replace('>>', ''), 10);
                if(postNum > 0 && postNum <= posts.length){
                    const targetPostId = posts[postNum - 1].id;
                    anchorCounts[targetPostId] = (anchorCounts[targetPostId] || 0) + 1;
                }
            });
        }
    });
    const postsHtml = posts.map((post, idx) => generatePostHtml(post, idx + 1, t, anchorCounts)).join('');
    document.getElementById('app').innerHTML = `<div class="card"><div class="thread-header"><div class="thread-header-main"><h2>${escapeHTML(t.title)}</h2></div><div class="thread-header-meta"><div class="small-muted">ä½œæˆ: ${formatTimestamp(t.createdAt)}</div><div class="small-muted" style="margin-top:4px;">é–²è¦§ä¸­: <span id="viewer-count">${currentViewers}</span>äºº</div></div></div><div style="display:flex; justify-content:flex-end; margin-bottom:8px;">${deleteBtnHtml}</div><div class="search-box" style="padding: 12px; background: var(--bg); border-radius: 8px; margin-bottom: 12px;"><input type="text" id="threadSearchInput" placeholder="ã“ã®ã‚¹ãƒ¬å†…ã‚’æ¤œç´¢"><button id="threadSearchBtn" class="btn small">æ¤œç´¢</button><button id="threadSearchClearBtn" class="btn small">ã‚¯ãƒªã‚¢</button></div></div><div class="card" id="postsContainer">${postsHtml}</div><div class="card">${rF}</div>`;
    
    if(window.twttr && twttr.widgets) twttr.widgets.load(document.getElementById('postsContainer'));
    
    if (pC < POST_LIMIT) {
        document.getElementById('replyBtn').onclick = () => postReply(id);
        setupVoteModal('replyText');
        setupDrawingModal('replyImageContainer');
    }
    const searchInput = document.getElementById('threadSearchInput');
    const searchBtn = document.getElementById('threadSearchBtn');
    const clearBtn = document.getElementById('threadSearchClearBtn');
    const updateHighlighting = (keyword) => {
        document.querySelectorAll('#postsContainer .post .body').forEach(body => {
            body.querySelectorAll('span.search-highlight').forEach(span => span.replaceWith(...span.childNodes));
            body.normalize(); 
            if (keyword && keyword.trim() !== '') {
                try {
                  const regex = new RegExp(escapeHTML(keyword.trim()).replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                  body.innerHTML = body.innerHTML.replace(regex, `<span class="search-highlight">$&</span>`);
                } catch(e) { /* Invalid regex */ }
            }
        });
    };
    const performSearch = () => {
        const keyword = searchInput.value.trim();
        updateHighlighting(keyword);
        document.querySelectorAll('#postsContainer .post').forEach(post => {
            const body = post.querySelector('.body');
            post.style.display = (!body || keyword === '' || body.textContent.toLowerCase().includes(keyword.toLowerCase())) ? 'block' : 'none';
        });
    };
    searchBtn.onclick = performSearch;
    searchInput.onkeydown = (e) => { if (e.key === 'Enter') performSearch(); };
    clearBtn.onclick = () => { searchInput.value = ''; performSearch(); };
  }

  function updateThreadViewSmart(id, t) {
    if (!t) { removeFromHistory(id); goHome(); return; }
    const postsContainer = document.getElementById('postsContainer');
    if (!postsContainer) return;
    const u = getUser();
    const newPosts = Object.values(t.posts || {}).sort((a, b) => a.createdAt - b.createdAt);
    const anchorCounts = {};
    newPosts.forEach((p, postIndex) => {
        if (p.text) {
            (p.text.match(/>>(\d+)/g) || []).forEach(anchor => {
                const postNum = parseInt(anchor.replace('>>', ''), 10);
                if(postNum > 0 && postNum <= newPosts.length){
                    const targetPostId = newPosts[postNum - 1].id;
                    anchorCounts[targetPostId] = (anchorCounts[targetPostId] || 0) + 1;
                }
            });
        }
    });
    const existingPostElements = postsContainer.querySelectorAll('.post');
    if (newPosts.length > existingPostElements.length) {
      for (let i = existingPostElements.length; i < newPosts.length; i++) {
        const postHtml = generatePostHtml(newPosts[i], i + 1, t, anchorCounts);
        postsContainer.insertAdjacentHTML('beforeend', postHtml);
        if (window.twttr && twttr.widgets) twttr.widgets.load(postsContainer.lastElementChild);
      }
    }
    newPosts.forEach((post, idx) => {
        const postElement = postsContainer.querySelector(`[data-post-id="${post.id}"]`);
        if (!postElement) return;
        if (currentEditState && post.id === currentEditState.postId) {
            const reacs = post.reactions || {};
            postElement.querySelectorAll('[data-action="react"]').forEach(btn => {
                const reacType = btn.dataset.reac;
                let count = Object.values(reacs).filter(r => r === reacType).length;
                const isMyReaction = reacs[u.permanentId] === reacType;
                btn.textContent = `${isMyReaction ? REACTION_PAIRS[reacType] : reacType} ${count}`;
                btn.classList.toggle('liked', isMyReaction);
            });
            return; 
        }
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = generatePostHtml(post, idx + 1, t, anchorCounts);
        if (tempDiv.firstChild && postElement.innerHTML !== tempDiv.firstChild.innerHTML) {
          postElement.replaceWith(tempDiv.firstChild);
        }
    });
    if(effectObserver) {
        document.querySelectorAll('[data-effect]:not(.observed)').forEach(el => {
            effectObserver.observe(el);
            el.classList.add('observed');
        });
    }
  }

  function setupEffectObserver() {
    if (effectObserver) {
        effectObserver.disconnect();
    }
    effectObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const postElement = entry.target;
                const effect = postElement.dataset.effect;
                const activeClass = `effect-${effect}-active`;
                
                postElement.classList.add(activeClass);

                setTimeout(() => {
                    postElement.classList.remove(activeClass);
                }, 3000);
                
                effectObserver.unobserve(postElement);
            }
        });
    });

    document.querySelectorAll('[data-effect]').forEach(el => {
        effectObserver.observe(el);
        el.classList.add('observed');
    });
  }

  // â˜…â˜…â˜… [æœ€çµ‚ç‰ˆ] ã‚¹ãƒ¬ãƒƒãƒ‰æç”»é–¢æ•° â˜…â˜…â˜…
  async function renderThread(id) {
    const myId = getUser().permanentId;
    if (myId && myId !== "TEMP_ID") {
        // â˜…â˜…â˜… ä¿®æ­£ç‚¹3: é€šçŸ¥ãŒæ¶ˆãˆãªã„ãƒã‚°ã®ä¿®æ­£ â˜…â˜…â˜…
        const updates = {};
        const notificationsToMarkRead = [];

        // [å¤‰æ›´] ã¾ãšæ›´æ–°å¯¾è±¡ã®é€šçŸ¥ã‚’ãƒªã‚¹ãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹
        Object.entries(globalUnreadNotifications).forEach(([notifId, notif]) => {
            if (notif && !notif.read && notif.threadId === id) {
                updates[`/userNotifications/${myId}/${notifId}/read`] = true;
                notificationsToMarkRead.push(notifId);
            }
        });

        if (notificationsToMarkRead.length > 0) {
            // [è¿½åŠ ] ãƒ­ãƒ¼ã‚«ãƒ«ã®é€šçŸ¥ãƒ‡ãƒ¼ã‚¿ã‚‚å³åº§ã«æ›´æ–°ã™ã‚‹
            notificationsToMarkRead.forEach(notifId => {
                if (globalUnreadNotifications[notifId]) {
                    globalUnreadNotifications[notifId].read = true;
                }
            });
            // [è¿½åŠ ] ãƒãƒƒã‚¸ã®è¡¨ç¤ºã‚’å³åº§ã«æ›´æ–°ã™ã‚‹
            updateTotalUnreadBadge();
            
            // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®æ›´æ–°ã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§è¡Œã†
            db.ref().update(updates).catch(err => console.error("é€šçŸ¥ã®æ—¢èª­åŒ–ã«å¤±æ•—:", err));
        }
    }

    document.getElementById('app').innerHTML = ''; // å…ˆã«ã‚¯ãƒªã‚¢
    startLoadingAnimation(document.getElementById('app'), 'ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èª­ã¿è¾¼ã¿ä¸­');
    
    try {
      const [threadSnapshot, userLevelsSnapshot, achievementsSnapshot] = await Promise.all([
          db.ref('threads/'+id).once('value'),
          db.ref('userLevels').once('value'),
          db.ref('userAchievements').once('value'),
      ]);

      const threadData = threadSnapshot.val();
      userLevelsCache = userLevelsSnapshot.val() || {};
      userAchievementsCache = achievementsSnapshot.val() || {};

      if (!threadData) {
          stopLoadingAnimation();
          document.getElementById('app').innerHTML = `<div class="card"><div class="banned-note">ã‚¹ãƒ¬ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹ã€å‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚</div></div>`;
          removeFromHistory(id);
          return;
      }
      
      myTotalExp = (userLevelsCache[(getUser().permanentId)] || {}).exp || 0;
      
      if(threadData.levelRestriction > 0 && getLevel(myTotalExp) < threadData.levelRestriction) {
          stopLoadingAnimation();
          document.getElementById('app').innerHTML = `<div class="card"><div class="banned-note">ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é–²è¦§ãƒ»æŠ•ç¨¿ã™ã‚‹ã«ã¯ Lv.${threadData.levelRestriction} ä»¥ä¸ŠãŒå¿…è¦ã§ã™ã€‚</div></div>`;
          return;
      }

      addToHistory(id, threadData.title, threadData.lastUpdatedAt);
      stopLoadingAnimation(); // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’æ­¢ã‚ã¦ã‹ã‚‰æç”»
      fullRenderThreadView(id, threadData);
      
      setupEffectObserver();
      
      const vRef = db.ref('viewers/' + id);
      myConnectionRef = vRef.child(getUser().permanentId);

      const startHeartbeat = () => {
          myConnectionRef.set(firebase.database.ServerValue.TIMESTAMP);
          myConnectionRef.onDisconnect().remove();
          heartbeatInterval = setInterval(() => {
              if (myConnectionRef) myConnectionRef.set(firebase.database.ServerValue.TIMESTAMP);
          }, 30000);
      };

      const viewersRef = db.ref('viewers/' + id);
      myConnectionRef = viewersRef.child(getUser().permanentId);

      // 1. ã¾ãšã€é–²è¦§è€…æ•°ã®å¤‰åŒ–ã‚’ç›£è¦–ã™ã‚‹ãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­ç½®ã™ã‚‹
      const viewersCallback = viewersRef.on('value', (snapshot) => {
          const count = snapshot.numChildren();
          // ç”»é¢ä¸Šã®è¡¨ç¤ºã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«æ›´æ–°
          const viewerElement = document.getElementById('viewer-count');
          if (viewerElement) {
              viewerElement.textContent = count;
          }
          // ã‚¹ãƒ¬ãƒƒãƒ‰ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼ˆä¸€è¦§ã§ä½¿ã‚ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ï¼‰ã‚‚æ›´æ–°
          db.ref('threadMetadata/' + id + '/viewerCount').set(count);
      });
      activeViewersListener = { ref: viewersRef, callback: viewersCallback };

      // 2. ãƒªã‚¹ãƒŠãƒ¼è¨­ç½®å¾Œã€è‡ªåˆ†ã®å­˜åœ¨ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«æ›¸ãè¾¼ã‚€
      // ã“ã‚Œã«ã‚ˆã‚Šã€ãƒªã‚¹ãƒŠãƒ¼ãŒè‡ªèº«ã®å‚åŠ ã‚’ç¢ºå®Ÿã«æ¤œçŸ¥ã™ã‚‹
      myConnectionRef.set(firebase.database.ServerValue.TIMESTAMP);
      myConnectionRef.onDisconnect().remove();

      // 3. å®šæœŸçš„ã«ç”Ÿå­˜ç¢ºèªä¿¡å·ã‚’é€ã‚‹
      heartbeatInterval = setInterval(() => {
          if (myConnectionRef) myConnectionRef.set(firebase.database.ServerValue.TIMESTAMP);
      }, 30000);
      // â–²â–²â–²â–²â–² ã“ã“ã¾ã§ãŒæ”¹è‰¯ç‰ˆã®ã‚³ãƒ¼ãƒ‰ â–²â–²â–²â–²â–²

      const cb = db.ref('threads/'+id).on('value', s => {
          const currentData = s.val();
          if (currentData) {
              updateThreadViewSmart(id, currentData);
          } else {
               updateThreadViewSmart(id, null);
          }
      }, e => { console.error(e); document.getElementById('app').innerHTML = `<div class="card"><div class="banned-note">ã‚¹ãƒ¬ãƒƒãƒ‰ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</div></div>`;});
      activeDataListener={ref:db.ref('threads/'+id),callback:cb};
    } catch (e) {
        console.error("ã‚¹ãƒ¬ãƒƒãƒ‰ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:", e);
        stopLoadingAnimation();
        document.getElementById('app').innerHTML = `<div class="card"><div class="banned-note">ã‚¹ãƒ¬ãƒƒãƒ‰ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚</div></div>`;
    }
  }

  function processSpecialCommands(rawText, user) {
      let result = {
          text: rawText,
          effect: null,
          isCommandPost: false,
          isEffectCommandUsed: false,
      };
      
      const effectRegex = /!(shake|rainbow)/i;
      const effectMatch = result.text.match(effectRegex);
      if (effectMatch) {
          result.isCommandPost = true;
          result.isEffectCommandUsed = true;
          const lastUsed = parseInt(localStorage.getItem(EFFECT_COOLDOWN_KEY), 10) || 0;
          if (Date.now() - lastUsed < EFFECT_COOLDOWN_SECONDS * 1000) {
              throw new Error(`éš ã—ã‚³ãƒãƒ³ãƒ‰ã¯${EFFECT_COOLDOWN_SECONDS}ç§’ã«1å›ã¾ã§ã§ã™ã€‚`);
          }
          result.effect = effectMatch[1].toLowerCase();
          result.text = result.text.replace(effectRegex, '').trim();
      }

      const omikujiRegex = /!omikuji/i;
      if (result.text.match(omikujiRegex)) {
          result.isCommandPost = true;
          const results = [
              { name: 'ğŸ¥ºå¤§å‰ğŸ‘‘', text: 'ã„ã„ã“ã¨ãŒã‚ã‚Šãã†ã âœ‹ğŸ¥ºä½•ã‚’ã‚„ã£ã¦ã‚‚ã†ã¾ãã„ãã§ã—ã‚‡ã†âœ‹ğŸ˜', effect: 'rainbow' },
              { name: 'ğŸ¤¥ä¸­å‰ğŸ˜³', text: 'å®¶ã®å‰ã«ãŠã‹ã¡ãŒè½ã¡ã¦ã‚‹ã§ã—ã‚‡ã†âœ‹ğŸ¥ºã‚ˆã‹ã£ãŸã­âœ‹ğŸ¥º', effect: null },
              { name: 'ğŸ¥ºå‰ğŸ¥º', text: 'æ™®é€šã®1æ—¥ã«ãªã‚Šãã†âœ‹ğŸ¥º', effect: null },
              { name: 'ğŸ˜ å‡¶ğŸ¤“', text: 'é›»é€šæ¡ˆä»¶ã ãğŸ˜ ', effect: null },
              { name: 'ğŸ˜¡å¤§å‡¶ğŸ˜¡', text: 'é›¢å©šç¢ºå®šã€2äººã®å­ä¾›ã®è¦ªæ¨©ã‚‚å–ã‚‰ã‚Œã‚‹ã ã‚ã†âœ‹ğŸ˜¡ğŸ¤š', effect: 'shake' }
          ];
          const items = ['ã¡ã£ã¡ã‚ƒã„é›»æ°—ğŸ’¡', 'ã˜ã‚‡ã†ã¡ğŸ§‘â€ğŸ’¼', 'ã‚¬ãƒ³ãƒ—ãƒ©', 'ã†ã‚“ã¡ğŸ’©', 'ãƒŸãƒ‹ãƒ¯ã‚¤ğŸ¥¹'];
          
          const seed = user.id + getJstDateString();
          let hash = 0;
          for (let i = 0; i < seed.length; i++) {
              const char = seed.charCodeAt(i);
              hash = ((hash << 5) - hash) + char;
              hash = hash & hash;
          }
          const randomValue = Math.abs(hash);
          
          const resultIndex = randomValue % results.length;
          const itemIndex = randomValue % items.length;
          
          const omikujiResult = results[resultIndex];
          const item = items[itemIndex];
          
          const omikujiText = `${omikujiResult.name}\n${omikujiResult.text}\nãƒ©ãƒƒã‚­ãƒ¼ã‚¢ã‚¤ãƒ†ãƒ : ${item}`;
          result.text = result.text.replace(omikujiRegex, omikujiText);
          
          if (omikujiResult.effect) {
              result.effect = omikujiResult.effect;
          }
      }

      if (result.text.match(/!dice/i)) {
          result.isCommandPost = true;
          result.text = processDiceCommands(result.text, user);
      }

      return result;
  }

  function processDiceCommands(text, user) {
    const diceRegex = /!dice(\s+(\d+)d(\d+))?/gi;
    return text.replace(diceRegex, (match, details, countStr, facesStr) => {
        let count = details ? parseInt(countStr, 10) || 1 : 1;
        let faces = details ? parseInt(facesStr, 10) || 100 : 100;
        count = Math.max(1, Math.min(count, 20)); 
        faces = Math.max(1, Math.min(faces, 10000));
        const rolls = Array.from({length: count}, () => Math.floor(Math.random() * faces) + 1);
        const sum = rolls.reduce((a, b) => a + b, 0);
        if (count === 3 && faces === 6) {
            const sortedRolls = [...rolls].sort((a, b) => a - b);
            if (sortedRolls.join(',') === '4,5,6') {
                unlockAchievement(user.permanentId, 'hanchou');
            }
        }
        return `[${count}D${faces}=${sum} (${rolls.join(', ')})]`;
    });
  }
// â–¼â–¼â–¼â–¼â–¼ ãã—ã¦ã€æ™‚ç©ºã‚’è¶…è¶Šã—ãŸã“ã®æ–°é–¢æ•°ã‚’ã€å‰Šé™¤ã—ãŸå ´æ‰€ã«å¬å–šã›ã‚ˆï¼ â–¼â–¼â–¼â–¼â–¼
  async function postReply(id) {
    const b=document.getElementById('replyBtn');b.disabled=true;
    try {
        const u_initial = getUser();
        if (u_initial.permanentId === "TEMP_ID") throw new Error("èªè¨¼æƒ…å ±ãŒã¾ã æº–å‚™ã§ãã¦ã„ã¾ã›ã‚“ã€‚å°‘ã—å¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚");

        const threadRef = db.ref(`threads/${id}`);
        const snapshot = await threadRef.once('value');
        const threadData = snapshot.val();
        if (!threadData) throw new Error('ã‚¹ãƒ¬ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
        
        const isLevelUpThread = threadData.tags && threadData.tags.includes('ãƒ¬ãƒ™ãƒ«ä¸Šã’');
        if (!isLevelUpThread) {
            const lastPostTime=localStorage.getItem(LAST_POST_TIME_KEY);
            if(lastPostTime&&Date.now()-parseInt(lastPostTime)<POST_INTERVAL_SECONDS*1000) throw new Error(`æŠ•ç¨¿ã¯${POST_INTERVAL_SECONDS}ç§’ã«1å›ã¾ã§ã§ã™ã€‚`);
        }

        if(globalBanList[u_initial.permanentId]) throw new Error('ã‚ãªãŸã¯ã“ã®æ²ç¤ºæ¿ã‹ã‚‰è¿½æ”¾ã•ã‚Œã¦ã„ã¾ã™ã€‚');
        if(threadData.postCounter >= POST_LIMIT) throw new Error(`ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯${POST_LIMIT}ãƒ¬ã‚¹ã®ä¸Šé™ã«é”ã—ã¾ã—ãŸã€‚`);
        
        const nN = document.getElementById('replyName').value.trim();
        const iS = nN.toLowerCase().includes('sage');
        
        let finalName = u_initial.name;

        if (!iS && nN && nN !== u_initial.name) {
            if (!setUserName(nN)) throw new Error(`åå‰ã¯${NAME_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
            finalName = nN;
        }
        
        let rawText = document.getElementById('replyText').value;
        let postDataProcessed = processSpecialCommands(rawText, u_initial);
        const t = postDataProcessed.text.trim();
        const fileInput = document.getElementById('replyImage');
        const f = fileInput ? fileInput.files[0] : null;

        if (!t && !f && !drawingDataUrl && !postDataProcessed.effect) throw new Error('æœ¬æ–‡ãƒ»ç”»åƒãƒ»ãŠçµµæãã®ã„ãšã‚Œã‹ãŒå¿…è¦ã§ã™');

        if(drawingDataUrl && (drawingDataUrl.length * 0.75 > MAX_IMAGE_BYTES)) throw new Error(`ãŠçµµæãç”»åƒã®ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™ã€‚`);
        if(t.length > TEXT_LIMIT) throw new Error(`æœ¬æ–‡ã¯${TEXT_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
        if((rawText.match(/\n/g) || []).length > MAX_NEWLINES) throw new Error(`æ”¹è¡Œã¯${MAX_NEWLINES}å›ã¾ã§ã§ã™ã€‚`);
        if(rawText.match(new RegExp(`\\n{${MAX_CONSECUTIVE_NEWLINES + 1},}`))) throw new Error(`é€£ç¶šã—ãŸæ”¹è¡Œã¯${MAX_CONSECUTIVE_NEWLINES}å›ã¾ã§ã§ã™ã€‚`);
        if(nN.length > NAME_LIMIT) throw new Error(`åå‰ã¯${NAME_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
        if(containsNGWord(t) || containsNGWord(nN)) throw new Error('ä¸é©åˆ‡ãªå˜èªãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚');
        if(threadData.banned && threadData.banned[u_initial.permanentId]) throw new Error('ã‚ãªãŸã¯ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã‚¢ã‚¯ç¦ã•ã‚Œã¦ã„ã¾ã™ã€‚');
        
        if (postDataProcessed.effect && !t) {
          throw new Error('!rainbow ã‚„ !shake ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯ã€ä½•ã‹æœ¬æ–‡ã‚‚å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
        }
        if (postDataProcessed.isEffectCommandUsed) {
          unlockAchievement(u_initial.permanentId, 'eye_puyuyu');
        }
        
        const i = drawingDataUrl ? drawingDataUrl : (f ? await readFileAsDataURL(f) : null);
        
        const finalAuthor = { permanentId: u_initial.permanentId, id: u_initial.id, name: finalName };
        
        const createPost = functions.httpsCallable('createPost');
        await createPost({
            threadId: id,
            isNewThread: false,
            postData: {
                author: finalAuthor,
                text: t,
                img: i,
                createdAt: firebase.database.ServerValue.TIMESTAMP,
                effect: postDataProcessed.effect || null,
                isCommandPost: postDataProcessed.isCommandPost || null,
            },
            shouldUpdateTimestamp: !iS && !isLevelUpThread
        });

        localStorage.setItem(LAST_POST_TIME_KEY,Date.now().toString());
        if(postDataProcessed.isEffectCommandUsed) localStorage.setItem(EFFECT_COOLDOWN_KEY, Date.now().toString());

        document.getElementById('replyText').value='';
        drawingDataUrl = null;
        const imgContainer = document.getElementById('replyImageContainer');
        imgContainer.innerHTML = '<input id="replyImage" type="file" accept="image/*">';
    }catch(e){
        alert('æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼: '+ (e.details ? e.details.message : e.message));
    }finally{
        if(b) b.disabled=false;
    }
  }
// â–²â–²â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–²â–²â–²

  
  function containsNGWord(t){const l=t.toLowerCase();return NG_WORDS.some(w=>l.includes(w.toLowerCase()));}
  function readFileAsDataURL(f){if(!f.type.startsWith('image/'))throw new Error('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');if(f.size>MAX_IMAGE_BYTES)throw new Error(`ç”»åƒã‚µã‚¤ã‚ºã¯${MAX_IMAGE_BYTES/1024/1024}MBä»¥ä¸‹ã«ã—ã¦ãã ã•ã„`);return new Promise((s,j)=>{const r=new FileReader();r.onload=()=>s(r.result);r.onerror=j;r.readAsDataURL(f);});}

  function createThumbnail(dataUrl, maxWidth, maxHeight) {
      return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              let width = img.width;
              let height = img.height;

              if (width > height) {
                  if (width > maxWidth) {
                      height *= maxWidth / width;
                      width = maxWidth;
                  }
              } else {
                  if (height > maxHeight) {
                      width *= maxHeight / height;
                      height = maxHeight;
                  }
              }
              canvas.width = width;
              canvas.height = height;
              ctx.drawImage(img, 0, 0, width, height);
              resolve(canvas.toDataURL('image/jpeg', 0.8));
          };
          img.onerror = (err) => reject(err);
          img.src = dataUrl;
      });
  }

  function setupVoteModal(textareaId){
    const oB=document.getElementById('createVoteBtn');if(!oB)return;
    const m=document.getElementById('voteModal'),cM=document.getElementById('closeVoteModalBtn'),aO=document.getElementById('addVoteOptionBtn'),iB=document.getElementById('insertVoteBtn'),con=document.getElementById('voteOptionsContainer'),dS=document.getElementById('voteDeadlineSelect');
    
    const handler = () => { m.style.display = 'flex'; };
    oB.addEventListener('click', handler);
    drawingEventListeners.push({ element: oB, type: 'click', handler });

    cM.onclick=()=>{m.style.display='none';};
    m.onclick=(e)=>{if(e.target===e.currentTarget)m.style.display='none';};
    aO.onclick=()=>{if(con.children.length<10){const i=document.createElement('input');i.type='text';i.className='vote-option-input';i.placeholder=`é¸æŠè‚¢${con.children.length+1}`;i.style.marginBottom='8px';con.appendChild(i);}};
    iB.onclick=()=>{const opts=Array.from(con.getElementsByClassName('vote-option-input')).map(i=>i.value.trim()).filter(v=>v!=='');if(opts.length<2){alert('æœ‰åŠ¹ãªé¸æŠè‚¢ã‚’2ã¤ä»¥ä¸Šå…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');return;}if(new Set(opts).size!==opts.length){alert('é¸æŠè‚¢ãŒé‡è¤‡ã—ã¦ã„ã¾ã™ã€‚');return;}if(opts.some(o=>o.length>VOTE_OPTION_LIMIT)){alert(`é¸æŠè‚¢ã¯${VOTE_OPTION_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);return;}const deadline=parseInt(dS.value,10)>0?Date.now()+parseInt(dS.value,10):0;const tag=`[vote(${deadline}):${opts.join(',')}]`;document.getElementById(textareaId).value+=`\n${tag}\n`;m.style.display='none';};
  }
  
  function setupDrawingModal(imageContainerId) {
    const drawBtn = document.getElementById('createDrawBtn');
    if (!drawBtn) return;
    const modal = document.getElementById('drawingModal'),
          closeBtn = document.getElementById('closeDrawingModalBtn'),
          canvas = document.getElementById('drawingCanvas'),
          sizeSelect = document.getElementById('canvasSizeSelect'),
          ctx = canvas.getContext('2d', { willReadFrequently: true }),
          bgColorPicker = document.getElementById('bgColorPicker'),
          colorPicker = document.getElementById('colorPicker'),
          brushSizeSlider = document.getElementById('brushSize'),
          brushSizeValue = document.getElementById('brushSizeValue'),
          clearBtn = document.getElementById('clearCanvasBtn'),
          insertBtn = document.getElementById('insertDrawingBtn'),
          undoBtn = document.getElementById('undoBtn'),
          redoBtn = document.getElementById('redoBtn'),
          penBtn = document.getElementById('penBtn'),
          markerBtn = document.getElementById('markerBtn'),
          sprayBtn = document.getElementById('sprayBtn'),
          fillBtn = document.getElementById('fillBtn'),
          eraserBtn = document.getElementById('eraserBtn');
    
    let isDrawing = false, lastX = 0, lastY = 0;
    let currentTool = 'pen';
    let currentBgColor = '#FFFFFF';
    
    let history = [];
    let historyIndex = -1;
    const HISTORY_LIMIT = 30;

    const getPointerPos = (e) => {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { 
            x: (clientX - rect.left) * (canvas.width / rect.width), 
            y: (clientY - rect.top) * (canvas.height / rect.height)
        };
    };
    
    const updateHistory = () => {
        if (historyIndex < history.length - 1) {
            history = history.slice(0, historyIndex + 1);
        }
        history.push({
            imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
            bgColor: currentBgColor 
        });
        if (history.length > HISTORY_LIMIT) {
            history.shift();
        }
        historyIndex = history.length - 1;
        updateUndoRedoButtons();
    };

    const updateUndoRedoButtons = () => {
        undoBtn.disabled = historyIndex <= 0;
        redoBtn.disabled = historyIndex >= history.length - 1;
    };

    const restoreHistory = () => {
        const historyEntry = history[historyIndex];
        if (historyEntry) {
            ctx.putImageData(historyEntry.imageData, 0, 0);
            currentBgColor = historyEntry.bgColor;
            bgColorPicker.value = historyEntry.bgColor;
        }
    };
    
    const undo = () => {
        if (historyIndex > 0) {
            historyIndex--;
            restoreHistory();
            updateUndoRedoButtons();
        }
    };
    
    const redo = () => {
        if (historyIndex < history.length - 1) {
            historyIndex++;
            restoreHistory();
            updateUndoRedoButtons();
        }
    };

    const fillBackground = (save = true) => {
        ctx.fillStyle = currentBgColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        if(save) updateHistory();
    };

    const setActiveTool = (tool) => {
        currentTool = tool;
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`${tool}Btn`)?.classList.add('active');
        canvas.style.cursor = tool === 'fill' ? 'copy' : 'crosshair';
    };

    const setBrush = () => {
      ctx.lineJoin = 'round'; ctx.lineCap = 'round';
      ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1.0;
      ctx.lineWidth = brushSizeSlider.value;
      
      switch (currentTool) {
        case 'eraser':
            ctx.strokeStyle = currentBgColor;
            break;
        case 'marker':
            ctx.strokeStyle = colorPicker.value;
            ctx.globalAlpha = 0.2;
            break;
        case 'spray':
        case 'pen':
        default:
            ctx.strokeStyle = colorPicker.value;
            break;
      }
    };
    
    const draw = (e) => {
        if (!isDrawing) return;
        e.preventDefault();
        setBrush();
        const { x, y } = getPointerPos(e);

        if (currentTool === 'spray') {
            const density = brushSizeSlider.value * 2;
            const radius = brushSizeSlider.value;
            ctx.fillStyle = colorPicker.value;
            for (let i = density; i--; ) {
                const angle = Math.random() * 2 * Math.PI;
                const r = Math.random() * radius;
                ctx.fillRect(x + r * Math.cos(angle), y + r * Math.sin(angle), 1, 1);
            }
        } else {
            ctx.beginPath(); ctx.moveTo(lastX, lastY); ctx.lineTo(x, y); ctx.stroke();
        }
        [lastX, lastY] = [x, y];
    };
    
    const startDrawing = (e) => {
        if (currentTool === 'fill') { floodFill(getPointerPos(e)); return; }
        isDrawing = true;
        const { x, y } = getPointerPos(e);
        [lastX, lastY] = [x, y];
        draw(e);
    };
    
    const stopDrawing = () => {
        if (isDrawing) { isDrawing = false; updateHistory(); }
    };
    
    const floodFill = ({x, y}) => {
        const w = canvas.width, h = canvas.height;
        x = Math.round(x); y = Math.round(y);
        if (x < 0 || x >= w || y < 0 || y >= h) return;
        
        const imageData = ctx.getImageData(0, 0, w, h);
        const data = imageData.data;
        const startPos = (y * w + x) * 4;
        
        const startR = data[startPos], startG = data[startPos+1], startB = data[startPos+2];
        const hexToRgb = (hex) => { const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return r ? { r: parseInt(r[1], 16), g: parseInt(r[2], 16), b: parseInt(r[3], 16) } : null; };
        const fillRgb = hexToRgb(colorPicker.value);
        if (!fillRgb || (startR === fillRgb.r && startG === fillRgb.g && startB === fillRgb.b)) return;
        
        const tolerance = 32;
        const colorMatch = (pos) => {
            const dr = data[pos] - startR, dg = data[pos+1] - startG, db = data[pos+2] - startB;
            return (dr*dr + dg*dg + db*db) < tolerance * tolerance;
        };

        const pixelsToCheck = [[x, y]];
        const processed = new Uint8Array(w * h);

        while (pixelsToCheck.length > 0) {
            const [px, py] = pixelsToCheck.pop();
            const currentIdx = py * w + px;
            if (processed[currentIdx] === 1) continue;
            processed[currentIdx] = 1;

            const currentPos = currentIdx * 4;
            if (!colorMatch(currentPos)) continue;

            data[currentPos] = fillRgb.r; data[currentPos+1] = fillRgb.g; data[currentPos+2] = fillRgb.b; data[currentPos+3] = 255;
            
            if(px + 1 < w) pixelsToCheck.push([px + 1, py]);
            if(px - 1 >= 0) pixelsToCheck.push([px - 1, py]);
            if(py + 1 < h) pixelsToCheck.push([px, py + 1]);
            if(py - 1 >= 0) pixelsToCheck.push([px, py - 1]);
        }
        ctx.putImageData(imageData, 0, 0);
        updateHistory();
    };

    const resizeCanvas = () => {
        if(confirm('ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’å¤‰æ›´ã—ã¾ã™ã‹ï¼Ÿæç”»å†…å®¹ã¯ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚')) {
            const [width, height] = sizeSelect.value.split('x');
            canvas.width = parseInt(width, 10);
            canvas.height = parseInt(height, 10);
            history = [];
            historyIndex = -1;
            fillBackground(true);
        } else {
            const oldSize = `${canvas.width}x${canvas.height}`;
            sizeSelect.value = oldSize;
        }
    };
    
    const eventHandlers = {
        bgColorChange: () => { currentBgColor = bgColorPicker.value; fillBackground(true); },
        start: (e) => startDrawing(e),
        move: (e) => draw(e),
        stop: () => stopDrawing(),
        toolPen: () => setActiveTool('pen'),
        toolMarker: () => setActiveTool('marker'),
        toolSpray: () => setActiveTool('spray'),
        toolFill: () => setActiveTool('fill'),
        toolEraser: () => setActiveTool('eraser'),
        undo: () => undo(),
        redo: () => redo(),
        clear: () => { if(confirm('ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’å…¨æ¶ˆã—ã—ã¾ã™ã‹ï¼Ÿ')) { fillBackground(true); } },
        show: () => {
            modal.style.display = 'flex';
            const [width, height] = sizeSelect.value.split('x');
            canvas.width = parseInt(width, 10);
            canvas.height = parseInt(height, 10);
            history = []; historyIndex = -1;
            currentBgColor = '#FFFFFF'; bgColorPicker.value = '#FFFFFF';
            setActiveTool('pen');
            fillBackground(true);
        },
        hide: () => modal.style.display = 'none',
        hideOverlay: (e) => { if (e.target === e.currentTarget) modal.style.display = 'none'; },
        insert: () => {
            drawingDataUrl = canvas.toDataURL('image/png');
            const imageContainer = document.getElementById(imageContainerId);
            imageContainer.innerHTML = `<div id="drawingPreviewContainer"><img id="drawingPreview" src="${drawingDataUrl}"><button id="clearDrawingBtn" class="btn small warn">çµµã‚’å‰Šé™¤</button></div>`;
            document.getElementById('clearDrawingBtn').onclick = () => {
                drawingDataUrl = null;
                imageContainer.innerHTML = `<input id="${imageContainerId === 'newImageContainer' ? 'newImage' : 'replyImage'}" type="file" accept="image/*">`;
            };
            modal.style.display = 'none';
        }
    };

    const addManagedListener = (element, type, handler, options = {}) => {
        element.addEventListener(type, handler, options);
        drawingEventListeners.push({ element, type, handler, options });
    };
    
    addManagedListener(drawBtn, 'click', eventHandlers.show);
    addManagedListener(closeBtn, 'click', eventHandlers.hide);
    addManagedListener(modal, 'click', eventHandlers.hideOverlay);
    addManagedListener(bgColorPicker, 'change', eventHandlers.bgColorChange);
    addManagedListener(sizeSelect, 'change', resizeCanvas);
    addManagedListener(canvas, 'mousedown', eventHandlers.start);
    addManagedListener(canvas, 'mousemove', eventHandlers.move);
    addManagedListener(canvas, 'mouseup', eventHandlers.stop);
    addManagedListener(canvas, 'mouseout', eventHandlers.stop);
    addManagedListener(canvas, 'touchstart', eventHandlers.start, { passive: false });
    addManagedListener(canvas, 'touchmove', eventHandlers.move, { passive: false });
    addManagedListener(canvas, 'touchend', eventHandlers.stop);
    addManagedListener(penBtn, 'click', eventHandlers.toolPen);
    addManagedListener(markerBtn, 'click', eventHandlers.toolMarker);
    addManagedListener(sprayBtn, 'click', eventHandlers.toolSpray);
    addManagedListener(fillBtn, 'click', eventHandlers.toolFill);
    addManagedListener(eraserBtn, 'click', eventHandlers.toolEraser);
    addManagedListener(undoBtn, 'click', eventHandlers.undo);
    addManagedListener(redoBtn, 'click', eventHandlers.redo);
    addManagedListener(clearBtn, 'click', eventHandlers.clear);
    addManagedListener(insertBtn, 'click', eventHandlers.insert);
    addManagedListener(brushSizeSlider, 'input', () => { brushSizeValue.textContent = brushSizeSlider.value; });
  }

  window.react = async (threadId, postId, reac) => {
    const user = getUser();
    const reacRef = db.ref(`threads/${threadId}/posts/${postId}/reactions/${user.permanentId}`);
    
    const postAuthorSnapshot = await db.ref(`threads/${threadId}/posts/${postId}/author/permanentId`).once('value');
    const authorId = postAuthorSnapshot.val();

    await reacRef.transaction(currentReac => (currentReac === reac ? null : reac));

    if (reac === 'ğŸ¥º' && authorId) {
        const allReactionsSnapshot = await db.ref(`threads/${threadId}/posts/${postId}/reactions`).once('value');
        const allReactions = allReactionsSnapshot.val() || {};
        const puyoyuCount = Object.values(allReactions).filter(r => r === 'ğŸ¥º').length;

        if (puyoyuCount >= 10) {
            const achievementNotification = {
                type: "ACHIEVEMENT",
                achievementId: "popular_puyuyu",
                title: "äººæ°—è€…ğŸ¥º",
                text: "ã‚ãªãŸã®æŠ•ç¨¿ã¸ã®ğŸ¥ºãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒ10å€‹ã«åˆ°é”ã—ã¾ã—ãŸï¼",
                threadId: threadId,
                timestamp: Date.now(),
                read: false,
            };
            db.ref(`/userNotifications/${authorId}/${postId}_popular_puyuyu`).set(achievementNotification);
        }
    }
  };
  
  function exitEditMode(options = {}) {
      if (!currentEditState) return;
      const { postElement, originalControlsHTML, originalBodyHTML } = currentEditState;
      const bodyContainer = postElement.querySelector('.body-container');
      const controls = postElement.querySelector('.controls');
      if (options.postWasDeleted) {
          postElement.children[1].innerHTML = '<div class="deleted-note">[å‰Šé™¤ã•ã‚Œã¾ã—ãŸ]</div>';
      } else {
          const newBody = document.createElement('div');
          newBody.className = 'body';
          newBody.innerHTML = options.newText ? renderContent(options.newText) : originalBodyHTML;
          if (bodyContainer) bodyContainer.replaceWith(newBody);
          if (controls) controls.innerHTML = originalControlsHTML;
          if (options.newText) {
            if(window.twttr && twttr.widgets) twttr.widgets.load(postElement);
          }
      }
      currentEditState = null;
  }

  window.editPost = async (threadId, postId) => {
      if (currentEditState) exitEditMode();
      const postRef = db.ref(`threads/${threadId}/posts/${postId}`);
      const snapshot = await postRef.once('value');
      const originalPost = snapshot.val();
      if (!originalPost || originalPost.author.permanentId !== getUser().permanentId) return alert('è‡ªåˆ†ã®æŠ•ç¨¿ã—ã‹ç·¨é›†ã§ãã¾ã›ã‚“');
      
      if (originalPost.isCommandPost) {
        return alert('ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ãŸæŠ•ç¨¿ã¯ç·¨é›†ã§ãã¾ã›ã‚“ã€‚');
      }

      const postElement = document.querySelector(`[data-post-id="${postId}"]`);
      if (!postElement) return;
      const bodyElement = postElement.querySelector('.body');
      const controlsElement = postElement.querySelector('.controls');
      const bodyContainer = document.createElement('div');
      bodyContainer.className = 'body-container';
      bodyElement.replaceWith(bodyContainer);
      const originalBodyHTML = renderContent(originalPost.text, originalPost);
      const originalControlsHTML = controlsElement.innerHTML;
      currentEditState = { postId, threadId, postElement, originalBodyHTML, originalControlsHTML };
      const textarea = document.createElement('textarea');
      textarea.value = originalPost.text;
      textarea.style.cssText = 'width: 100%; min-height: 120px; resize: vertical; margin-top: 8px;';
      bodyContainer.innerHTML = '';
      bodyContainer.appendChild(textarea);
      textarea.focus();
      controlsElement.innerHTML = '';
      const saveBtn = document.createElement('button');
      saveBtn.className = 'btn small';
      saveBtn.textContent = 'ä¿å­˜';
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'btn small warn';
      cancelBtn.textContent = 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«';
      controlsElement.appendChild(cancelBtn);
      controlsElement.appendChild(saveBtn);
            saveBtn.onclick = async () => {
          const newText = textarea.value;
          if (newText.trim() === '' && !originalPost.img && !originalPost.effect) return alert('æœ¬æ–‡ã‚’ç©ºã«ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚');
          if (newText.length > TEXT_LIMIT) return alert(`æœ¬æ–‡ã¯${TEXT_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
          if (containsNGWord(newText)) return alert('ä¸é©åˆ‡ãªå˜èªãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚');
          
          saveBtn.disabled = true;
          saveBtn.textContent = 'ä¿å­˜ä¸­...';
          try {
              const editPostFunction = functions.httpsCallable('editPost');
              await editPostFunction({
                  threadId: threadId,
                  postId: postId,
                  newText: newText.trim()
              });

              exitEditMode({ newText: newText.trim() });
          } catch (e) {
              const errorMessage = e.details ? e.details.message : e.message;
              alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + (errorMessage || "ä¸æ˜ãªã‚¨ãƒ©ãƒ¼ã§ã™ã€‚"));
              saveBtn.disabled = false;
              saveBtn.textContent = 'ä¿å­˜';
          }
      };
      cancelBtn.onclick = () => exitEditMode();
  };
  
  window.deletePost=(t,p)=>{if(confirm('ã“ã®æŠ•ç¨¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ'))db.ref().update({[`threads/${t}/posts/${p}/text`]:'',[`threads/${t}/posts/${p}/img`]:null,[`threads/${t}/posts/${p}/deleted`]:true});};
  
  window.toggleGlobalBan = async (userPermanentId, name) => {
    const btn = event.target;
    btn.disabled = true;
    try {
      const ref = db.ref(`globalBan/${userPermanentId}`);
      const snapshot = await ref.once('value');
      const actionText = snapshot.val() ? 'æ°¸ä¹…è¿½æ”¾ã‚’è§£é™¤' : 'æ°¸ä¹…è¿½æ”¾';
      if (confirm(`${name} ã‚’ ${actionText} ã—ã¾ã™ã‹ï¼Ÿ`)) {
        await ref.set(snapshot.val() ? null : true);
        alert(`${name} ã®${actionText}ã«æˆåŠŸã—ã¾ã—ãŸã€‚`);
      }
    } catch (e) {
      alert("å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
    } finally {
      btn.disabled = false;
    }
  };

  window.showUserProfile = async (name, permanentId, isOpAdm, dailyId, postTimestamp, threadId) => {
    const modal = document.getElementById('profileModal'), 
          nameEl = document.getElementById('profileName'), 
          idEl = document.getElementById('profileId'), 
          postsListEl = document.getElementById('profilePostsList'), 
          controlsEl = document.getElementById('profileControls');
    
    nameEl.textContent = name;
    idEl.textContent = `Daily ID: ${dailyId}`;
    controlsEl.innerHTML = '';
    startLoadingAnimation(postsListEl, 'ä»Šæ—¥ã®æŠ•ç¨¿ã‚’æ¤œç´¢ä¸­');
    
    const currentUser = getUser();
    if((isOpAdm || ADMIN_IDS.includes(currentUser.permanentId)) && currentUser.permanentId !== permanentId) {
      const threadRef = db.ref(`threads/${threadId}`);
      const threadData = (await threadRef.once('value')).val();
      if (threadData && (threadData.op.permanentId === currentUser.permanentId || ADMIN_IDS.includes(currentUser.permanentId))) {
        const isBanned = threadData.banned && threadData.banned[permanentId];
        controlsEl.innerHTML += `<button class="btn small warn" onclick="window.toggleBan('${threadId}', '${permanentId}', '${escapeHTML(name).replace(/'/g, "\\'")}')">${isBanned ? 'ã“ã®ã‚¹ãƒ¬ã®ã‚¢ã‚¯ç¦è§£é™¤' : 'ã“ã®ã‚¹ãƒ¬ã§ã‚¢ã‚¯ç¦'}</button>`;
      }
      if(ADMIN_IDS.includes(currentUser.permanentId)) {
        const isGloballyBanned = (await db.ref(`globalBan/${permanentId}`).once('value')).val();
        controlsEl.innerHTML += `<button class="btn small warn" onclick="window.toggleGlobalBan('${permanentId}', '${escapeHTML(name).replace(/'/g, "\\'")}')">${isGloballyBanned ? 'æ°¸ä¹…è¿½æ”¾ã‚’è§£é™¤' : 'æ°¸ä¹…è¿½æ”¾'}</button>`;
      }
    }
    modal.style.display = 'flex';
    
    try {
      const targetDateStr = getJstDateStringFromTimestamp(parseInt(postTimestamp, 10));
      const history = loadHistory();
      let allFoundPosts = [];

      const promises = history.map(async (item) => {
          const postsSnapshot = await db.ref('threads/' + item.id + '/posts').orderByChild('author/permanentId').equalTo(permanentId).once('value');
          if (postsSnapshot.exists()) {
              const posts = postsSnapshot.val();
              const dailyPostsInThread = Object.values(posts).filter(post => {
                  return getJstDateStringFromTimestamp(post.createdAt) === targetDateStr;
              }).map(post => ({...post, threadTitle: item.title, threadId: item.id}));
              allFoundPosts.push(...dailyPostsInThread);
          }
      });
      
      await Promise.all(promises);

      const uniquePosts = Array.from(new Map(allFoundPosts.map(p => [p.id, p])).values());
      uniquePosts.sort((a, b) => b.createdAt - a.createdAt);
      
      stopLoadingAnimation();
      if (uniquePosts.length > 0) {
          const allPostsInCurrentThread = Object.values(threadDataCache[threadId] || {}).sort((a,b)=>a.createdAt-b.createdAt);
          postsListEl.innerHTML = uniquePosts.map(post => {
              let postNumText = '';
              if (post.threadId === threadId) {
                  const num = allPostsInCurrentThread.findIndex(p => p.id === post.id);
                  if (num !== -1) postNumText = `No.${num + 1}`;
              }
              return `<div class="post" style="border-bottom: 1px solid var(--border-color); padding: 8px 0;">
                  <div class="small-muted">ã‚¹ãƒ¬: <a href="#thread-${post.threadId}" onclick="window.closeUserProfile()">${escapeHTML(post.threadTitle)}</a> ${postNumText} (${formatTimestamp(post.createdAt)})</div>
                  <div class="body">${renderContent(post.text, post)}</div>
              </div>`;
          }).join('');
      } else {
          postsListEl.innerHTML = '<div class="small-muted">ã“ã®æ—¥ã®æŠ•ç¨¿ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚</div>';
      }
    } catch (e) {
      stopLoadingAnimation();
      postsListEl.innerHTML = `<div class="banned-note">æŠ•ç¨¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${e.message}</div>`;
    }
  };
  
  window.prepareNextThread = async (threadId) => {
    try {
        const snapshot = await db.ref(`threads/${threadId}`).once('value');
        const thread = snapshot.val();
        if (!thread) return;
        const partMatch = thread.title.match(/Part\.(\d+)/);
        const newTitle = partMatch ? thread.title.replace(/Part\.\d+/, `Part.${parseInt(partMatch[1]) + 1}`) : `${thread.title} Part.2`;
        const newText = `å‰ã‚¹ãƒ¬ï¼š${location.origin}${location.pathname}#thread-${thread.id}\n\n`;
        localStorage.setItem(NEXT_THREAD_DATA_KEY, JSON.stringify({ title: newTitle, text: newText }));
        goHome();
    } catch(e) {
        alert('æ¬¡ã‚¹ãƒ¬ã®æº–å‚™ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e.message);
    }
  };
  
  window.showAnchors = async (targetPostId, threadId) => {
      const modal = document.getElementById('anchorModal'), body = document.getElementById('anchorModalBody');
      startLoadingAnimation(body);
      modal.style.display = 'flex';
      try {
          const thread = (await db.ref(`threads/${threadId}`).once('value')).val();
          if (!thread || !thread.posts) throw new Error('ã‚¹ãƒ¬ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
          const allPosts = Object.values(thread.posts).sort((a, b) => a.createdAt - b.createdAt);
          const targetPostIndex = allPosts.findIndex(p => p.id === targetPostId) + 1;
          const anchorPosts = allPosts.filter(p => p.text && (p.text.match(/>>(\d+)/g) || []).some(a => parseInt(a.replace('>>', '')) === targetPostIndex));
          stopLoadingAnimation();
          body.innerHTML = anchorPosts.length > 0
            ? anchorPosts.map(post => `<div class="post"><div class="meta"><b class="post-author">${escapeHTML(post.author.name)}</b> <span class="small-muted">${formatTimestamp(post.createdAt)}</span></div><div class="body">${renderContent(post.text)}</div></div>`).join('')
            : '<div class="small-muted">ã“ã®æŠ•ç¨¿ã¸ã®è¿”ä¿¡ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</div>';
          
          if(window.twttr && twttr.widgets) twttr.widgets.load(body);
      } catch(e) {
          stopLoadingAnimation();
          body.innerHTML = `<div class="banned-note">è¿”ä¿¡ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${e.message}</div>`;
      }
  };

  window.closeUserProfile=()=>{document.getElementById('profileModal').style.display='none';};
  
  function applyTheme(t){
    const themeBtnIcon = document.querySelector('#themeToggleBtn');
    if(t==='dark'){
      document.body.classList.add('dark-mode');
      if(themeBtnIcon) themeBtnIcon.textContent = 'â˜€ï¸ ãƒ†ãƒ¼ãƒåˆ‡æ›¿';
    } else {
      document.body.classList.remove('dark-mode');
      if(themeBtnIcon) themeBtnIcon.textContent = 'ğŸŒ™ ãƒ†ãƒ¼ãƒåˆ‡æ›¿';
    }
  }

  async function awardDailyBonusIfNeeded() {
    const user = getUser();
    let activity = loadDailyActivity();
    const todayStr = getJstDateString();
    if (todayStr !== activity.date && activity.postCount > 0) {
        const bonus = Math.floor(activity.postCount / 2);
        if (bonus > 0) {
            const expRef = db.ref(`userLevels/${user.permanentId}/exp`);
            await expRef.transaction(currentExp => (currentExp || 0) + bonus);
        }
        activity = { date: todayStr, postCount: 0 };
        saveDailyActivity(activity);
    }
  }

  // â˜…â˜…â˜… [æœ€çµ‚ç‰ˆ] çµ±åˆé€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚¹ãƒŠãƒ¼ â˜…â˜…â˜…
  async function setupUnreadListeners() {
    activeUnreadListeners.forEach(l => {
        if (l.ref && l.type && l.callback) {
            l.ref.off(l.type, l.callback);
        }
    });
    activeUnreadListeners = [];
    if (activeAchievementListener) {
        activeAchievementListener.ref.off('value', activeAchievementListener.callback);
        activeAchievementListener = null;
    }

    globalUnreadNotifications = {};
    initialNotificationsLoaded = false;
    
    const myId = getUser().permanentId;
    if (!myId || myId === "TEMP_ID") return;

    const notificationsRef = db.ref(`userNotifications/${myId}`);
    let lastKnownTimestamp = 0;

    const initialSnapshot = await notificationsRef.orderByChild('timestamp').once('value');
    if (initialSnapshot.exists()) {
        initialSnapshot.forEach(child => {
            globalUnreadNotifications[child.key] = child.val();
            if (child.val().timestamp > lastKnownTimestamp) {
                lastKnownTimestamp = child.val().timestamp;
            }
        });
    }
    updateTotalUnreadBadge();
    initialNotificationsLoaded = true;

    const query = notificationsRef.orderByChild('timestamp').startAt(lastKnownTimestamp + 1);
    
    const addCallback = query.on('child_added', snapshot => {
        if (!initialNotificationsLoaded || globalUnreadNotifications[snapshot.key]) return;

        const notificationId = snapshot.key;
        const newNotification = snapshot.val();
        globalUnreadNotifications[notificationId] = newNotification;
        
        if (newNotification.timestamp > lastKnownTimestamp) {
            lastKnownTimestamp = newNotification.timestamp;
        }

        updateTotalUnreadBadge();

        if (loadSoundSettings().enabled) {
            const sound = document.getElementById('notificationSound');
            if(sound) {
                sound.currentTime = 0;
                sound.play().catch(e => console.warn("ã‚µã‚¦ãƒ³ãƒ‰ã®è‡ªå‹•å†ç”ŸãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã—ãŸã€‚"));
            }
        }
    });
    activeUnreadListeners.push({ ref: query, type: 'child_added', callback: addCallback });

    const changeCallback = notificationsRef.on('child_changed', snapshot => {
        const notificationId = snapshot.key;
        if(globalUnreadNotifications[notificationId]){
            globalUnreadNotifications[notificationId] = snapshot.val();
            updateTotalUnreadBadge();
        }
    });
    activeUnreadListeners.push({ ref: notificationsRef, type: 'child_changed', callback: changeCallback });
    
    const removeCallback = notificationsRef.on('child_removed', snapshot => {
        const notificationId = snapshot.key;
        if(globalUnreadNotifications[notificationId]){
            delete globalUnreadNotifications[notificationId];
            updateTotalUnreadBadge();
        }
    });
    activeUnreadListeners.push({ ref: notificationsRef, type: 'child_removed', callback: removeCallback });
  }
  
  // â˜…â˜…â˜… [æœ€çµ‚ç‰ˆ] ãƒãƒƒã‚¸æ›´æ–°é–¢æ•° â˜…â˜…â˜…
  function updateTotalUnreadBadge() {
    const navUnreadBadge = document.getElementById('navHistoryUnreadBadge');
    if (!navUnreadBadge) return;
    
    const totalUnread = Object.values(globalUnreadNotifications).filter(n => n && !n.read).length;
    
    if (totalUnread > 0) {
        navUnreadBadge.textContent = totalUnread > 99 ? '99+' : totalUnread;
        navUnreadBadge.style.display = 'inline-flex';
    } else {
        navUnreadBadge.style.display = 'none';
    }
  }

  async function runArchiveCheckIfNeeded() {
      try {
          const stateRef = db.ref('appState/lastArchiveCheckTimestamp');
          const snapshot = await stateRef.once('value');
          const lastCheck = snapshot.val() || 0;
          const now = Date.now();
          const ONE_DAY_MS = 24 * 60 * 60 * 1000;

          if (now - lastCheck > ONE_DAY_MS) {
              await stateRef.set(now);

              const metaRef = db.ref('threadMetadata');
              const metaSnapshot = await metaRef.orderByChild('lastUpdatedAt').once('value');
              const allMeta = metaSnapshot.val();
              if (!allMeta) return;

              const updates = {};
              const SEVEN_DAYS_MS = 7 * ONE_DAY_MS;

              for (const threadId in allMeta) {
                  const thread = allMeta[threadId];
                  const tags = thread.tags || [];
                  const isExempt = tags.includes('ã·ã‚†ã‚†åé‘‘') || tags.includes('ãƒ¬ãƒ™ãƒ«ä¸Šã’');

                  if (!thread.isArchived && !isExempt && !thread.isHallOfFame && (now - thread.lastUpdatedAt > SEVEN_DAYS_MS)) {
                      updates[`/threadMetadata/${threadId}/isArchived`] = true;
                  }
              }

              if (Object.keys(updates).length > 0) {
                  await db.ref().update(updates);
              }
          }
      } catch (error) {
          console.error("ã‚¹ãƒ¬ãƒƒãƒ‰ã®è‡ªå‹•æ•´ç†ã«å¤±æ•—ã—ã¾ã—ãŸ:", error);
      }
  }

  function setActiveNavButton(hash) {
      document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
      let activeBtnId;
      if (hash.startsWith('#thread-')) {
      } else if (hash === '#history') {
          activeBtnId = 'navHistoryBtn';
      } else if (hash === '#settings') {
          activeBtnId = 'navSettingsBtn';
      } else {
          activeBtnId = 'navHomeBtn';
      }
      if (activeBtnId) {
          document.getElementById(activeBtnId).classList.add('active');
      }
  }

  const bannerImages = [
    'https://i.tto.jp/c06c.png',
    'https://i.tto.jp/1b4f.png',
    'https://i.tto.jp/d5dc.png',
    'https://i.tto.jp/fa97.png',
    'https://i.tto.jp/bee4.png',
    
  ];
  let currentBannerIndex = 0;
  
  function setupBanners() {
    const bannerContainer = document.getElementById('bannerSlideshow');
    if (!bannerContainer) return;
    bannerContainer.innerHTML = ''; 
    bannerImages.forEach((url, index) => {
      const img = document.createElement('img');
      img.src = url;
      if (index === 0) img.classList.add('active');
      bannerContainer.appendChild(img);
    });

    if (bannerInterval) clearInterval(bannerInterval);
    if (bannerImages.length > 1) {
      bannerInterval = setInterval(() => {
        const images = bannerContainer.getElementsByTagName('img');
        if (images.length === 0) return;
        images[currentBannerIndex].classList.remove('active');
        currentBannerIndex = (currentBannerIndex + 1) % bannerImages.length;
        images[currentBannerIndex].classList.add('active');
      }, 5000);
    }
  }

  function formatElapsedTime(timestamp) {
      const now = Date.now();
      const diffSeconds = Math.floor((now - timestamp) / 1000);

      if (diffSeconds < 60) return `${diffSeconds}ç§’å‰`;
      const diffMinutes = Math.floor(diffSeconds / 60);
      if (diffMinutes < 60) return `${diffMinutes}åˆ†å‰`;
      const diffHours = Math.floor(diffMinutes / 60);
      if (diffHours < 24) return `${diffHours}æ™‚é–“å‰`;
      const diffDays = Math.floor(diffHours / 24);
      if (diffDays < 365) return `${diffDays}æ—¥å‰`;
      const diffYears = Math.floor(diffDays / 365);
      return `${diffYears}å¹´å‰`;
  }

  function updateHeadlineTimes() {
    document.querySelectorAll('.headline-time[data-timestamp]').forEach(el => {
      el.textContent = formatElapsedTime(parseInt(el.dataset.timestamp, 10));
    });
  }

  function setupHeadlineListener() {
    if (activeHeadlineListener) {
        activeHeadlineListener.ref.off('value', activeHeadlineListener.callback);
    }
    if (headlineTimeUpdater) clearInterval(headlineTimeUpdater);

    const headlineRef = db.ref('/headlines').orderByChild('timestamp').limitToLast(5);
    const callback = headlineRef.on('value', async (snapshot) => {
        const container = document.getElementById('headlineContainer');
        if (!container) return;
        
        if (snapshot.exists()) {
            let headlines = [];
            snapshot.forEach(child => {
                headlines.unshift(child.val());
            });

            const metaPromises = headlines.map(h => 
                db.ref(`/threadMetadata/${h.threadId}/postCounter`).once('value')
            );
            const metaSnapshots = await Promise.all(metaPromises);

            let html = '';
            headlines.forEach((h, index) => {
                const postCounter = metaSnapshots[index].val() || '?';
                html += `<div class="headline-item">
                       <a href="#thread-${h.threadId}" data-action="jump-to-post" data-post-id="${h.postId}">
                         <span class="headline-title">ã€${escapeHTML(h.threadTitle)}ã€‘</span>
                         <span class="headline-res-count">(${postCounter})</span>
                         <span class="headline-text">${escapeHTML(h.text)}</span>
                         <span class="headline-time" data-timestamp="${h.timestamp}">${formatElapsedTime(h.timestamp)}</span>
                       </a>
                     </div>`;
            });
            container.innerHTML = html;
        } else {
            container.innerHTML = '<div class="headline-item">ã¾ã æŠ•ç¨¿ãŒã‚ã‚Šã¾ã›ã‚“...</div>';
        }
    });
    activeHeadlineListener = { ref: headlineRef, callback: callback };
    headlineTimeUpdater = setInterval(updateHeadlineTimes, 10000);
  }
  
  // â˜…â˜…â˜… [æœ€çµ‚ç‰ˆ] ã¡ã‚‰ã¤ãé˜²æ­¢ç­–ã‚’é©ç”¨ã—ãŸrenderAppé–¢æ•° â˜…â˜…â˜…
  async function renderApp() {
    exitEditMode();
    cleanupListeners();
    currentViewers = 0;
    refreshHeader();
    setupBanners();

    const headlineWrapper = document.getElementById('headlineWrapper');
    if (headlineWrapper) headlineWrapper.style.display = 'none';

    const appContainer = document.getElementById('app');
    if (appContainer) {
        startLoadingAnimation(appContainer, 'ãƒšãƒ¼ã‚¸ã‚’æº–å‚™ä¸­');
    }

    await awardDailyBonusIfNeeded();
    await setupUnreadListeners();

    const h = location.hash || '#';
    setActiveNavButton(h);

    if (h === '#' || h === '') {
        if (headlineWrapper) headlineWrapper.style.display = 'block';
        setupHeadlineListener();
    }

    try {
        if (h.startsWith('#thread-')) {
            await renderThread(h.replace('#thread-', ''));
        } else if (h === '#history') {
            await renderHistoryPage();
        } else if (h === '#settings') {
            await renderSettingsPage();
        } else if (h === '#memories') {
            await renderMemoriesPage();
        } else if (h === '#terms') {
            await renderTermsPage();
        } else {
            renderHome();
            const ref = db.ref('threadMetadata');
            const cb = ref.orderByChild('lastUpdatedAt').on('value', s => {
                stopLoadingAnimation();
                allThreads = s.val() ? Object.values(s.val()).filter(t => t && t.title).sort((a, b) => b.lastUpdatedAt - a.lastUpdatedAt) : [];
                if (typeof window.performDisplay === 'function') performDisplay();
            }, e => {
                stopLoadingAnimation();
                const c = document.getElementById('threadListContainer');
                if (c) c.innerHTML = `<div class="card"><div class="banned-note">ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</div></div>`;
            });
            activeDataListener = { ref, callback: cb };
        }
    } catch (error) {
        console.error("ãƒšãƒ¼ã‚¸ã®æç”»ã«å¤±æ•—ã—ã¾ã—ãŸ:", error);
        // â˜…â˜…â˜… ä¿®æ­£ç‚¹4: è¨­å®šç”»é¢ãŒé–‹ã‘ãªã„ãƒã‚°ã®ä¿®æ­£ â˜…â˜…â˜…
        stopLoadingAnimation();
        if (appContainer) {
            appContainer.innerHTML = `<div class="card"><div class="banned-note">ãƒšãƒ¼ã‚¸ã®è¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚</div></div>`;
        }
    }
  }
  
  window.castVote = async (threadId, postId, option) => {
    try {
        const postText = (await db.ref(`threads/${threadId}/posts/${postId}/text`).once('value')).val();
        if (postText && postText.match(/\[vote\((\d+)\):/)) {
            const deadline = parseInt(RegExp.$1, 10);
            if (deadline > 0 && Date.now() > deadline) return alert('ã“ã®ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆã¯ç· ã‚åˆ‡ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚');
        }
        db.ref(`threads/${threadId}/posts/${postId}/votes/${getUser().permanentId}`).transaction(v => v === option ? null : option);
    } catch (e) {
        alert("æŠ•ç¥¨ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
    }
  };

  document.querySelector('header h1').onclick = goHome;
  
  document.getElementById('navHomeBtn').onclick = () => {
    if (location.hash === '' || location.hash === '#') {
      renderApp();
    } else {
      goHome();
    }
  };
  document.getElementById('navHistoryBtn').onclick=()=>location.hash='history';
  document.getElementById('navSettingsBtn').onclick=()=>location.hash='settings';
  
  const menuBtn = document.getElementById('navMenuBtn');
  const sideMenuOverlay = document.getElementById('sideMenuOverlay');
  const sideMenu = document.getElementById('sideMenu');
  
  const toggleMenu = () => document.body.classList.toggle('menu-open');
  menuBtn.onclick = toggleMenu;
  sideMenuOverlay.onclick = toggleMenu;
  sideMenu.querySelectorAll('a, button').forEach(link => {
    link.onclick = (e) => {
      if (e.currentTarget.id !== 'themeToggleBtn' && document.body.classList.contains('menu-open')) {
        toggleMenu();
      }
    };
  });
  
  document.getElementById('themeToggleBtn').onclick=()=>{const nT=document.body.classList.contains('dark-mode')?'light':'dark';localStorage.setItem(THEME_KEY,nT);applyTheme(nT);};
  
  document.getElementById('closeProfileBtn').onclick=window.closeUserProfile;
  document.getElementById('profileModal').onclick=(e)=>{if(e.target===e.currentTarget)window.closeUserProfile();};
  const lightbox = document.getElementById('imageLightbox');
  lightbox.onclick=()=>lightbox.style.display='none';
  const anchorModal = document.getElementById('anchorModal');
  document.getElementById('closeAnchorModalBtn').onclick=()=>anchorModal.style.display='none';
  anchorModal.onclick=(e)=>{if(e.target===e.currentTarget)anchorModal.style.display='none';};

  const contactModal = document.getElementById('contactModal');
  document.getElementById('sideMenu').addEventListener('click', (e) => {
    if (e.target.id === 'contactAdminLink') {
        e.preventDefault();
        contactModal.style.display = 'flex';
        if(document.body.classList.contains('menu-open')) toggleMenu();
    }
  });
  document.getElementById('closeContactModalBtn').onclick=()=>contactModal.style.display='none';
  contactModal.onclick=(e)=>{if(e.target===e.currentTarget)contactModal.style.display='none';};

  const createThreadModal = document.getElementById('createThreadModal');
  const navCreateThreadBtn = document.getElementById('navCreateThreadBtn');
  const closeCreateThreadModalBtn = document.getElementById('closeCreateThreadModalBtn');

  navCreateThreadBtn.onclick = () => {
    document.getElementById('newTitle').value = '';
    document.getElementById('newText').value = '';
    document.getElementById('newImageContainer').innerHTML = '<input id="newImage" type="file" accept="image/*">';
    document.getElementById('newName').value = getUser().name;
    
    setupVoteModal('newText');
    setupDrawingModal('newImageContainer');
    
    createThreadModal.style.display = 'flex';
  };

  const closeCreateModal = () => {
    createThreadModal.style.display = 'none';
  };

  closeCreateThreadModalBtn.onclick = closeCreateModal;
  createThreadModal.onclick = (e) => {
    if (e.target === e.currentTarget) {
      closeCreateModal();
    }
  };
// â–¼â–¼â–¼â–¼â–¼ ãã—ã¦ã€æ™‚ç©ºã‚’è¶…è¶Šã—ãŸã“ã®æ–°é–¢æ•°ã‚’ã€å‰Šé™¤ã—ãŸå ´æ‰€ã«å¬å–šã›ã‚ˆï¼ â–¼â–¼â–¼â–¼â–¼
  document.getElementById('createThreadBtn').onclick=async()=>{
      const b=document.getElementById('createThreadBtn');
      try{
        const u_initial = getUser();
        if (u_initial.permanentId === "TEMP_ID") throw new Error("èªè¨¼æƒ…å ±ãŒã¾ã æº–å‚™ã§ãã¦ã„ã¾ã›ã‚“ã€‚å°‘ã—å¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚");
        
        if (globalBanList[u_initial.permanentId]) throw new Error('ã‚ãªãŸã¯ã“ã®æ²ç¤ºæ¿ã‹ã‚‰è¿½æ”¾ã•ã‚Œã¦ã„ã¾ã™ã€‚');
        
        const t = document.getElementById('newTitle').value.replace(/(\r\n|\n|\r)/gm, "").trim();
        const n = document.getElementById('newName').value.trim();
        let rawText = document.getElementById('newText').value;
        
        let finalName = u_initial.name;

        if (n && n !== u_initial.name) {
            if (!setUserName(n)) throw new Error(`åå‰ã¯${NAME_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
            finalName = n;
        }

        if (t.includes('å¾¡å¾’ç”º')) {
            b.disabled = true;
            b.textContent = 'å¤©æ°—æƒ…å ±å–å¾—ä¸­...';
            const weatherInfo = await getOkachimachiWeather();
            if (weatherInfo.startsWith('ã€å¤©æ°—æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‘')) {
                alert('å¤©æ°—æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å°‘ã—æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
                throw new Error('å¤©æ°—æƒ…å ±å–å¾—å¤±æ•—');
            }
            rawText = weatherInfo + rawText;
            b.disabled = false;
            b.textContent = 'ã‚¹ãƒ¬ä½œæˆ';
        }

        let postDataProcessed = processSpecialCommands(rawText, u_initial);
        const x = postDataProcessed.text.trim();
        const levelRestriction = parseInt(document.getElementById('levelRestrictionSelect').value, 10);
        const fileInput = document.getElementById('newImage');
        const f = fileInput ? fileInput.files[0] : null;

        const titleWithoutTags = t.replace(/#[\p{L}\p{N}_]+/ug,'').trim();
        if (!titleWithoutTags) throw new Error('ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        const hasContent = x || f || drawingDataUrl || postDataProcessed.effect;
        if (!hasContent) throw new Error('æœ¬æ–‡ãƒ»ç”»åƒãƒ»ãŠçµµæãã®ã„ãšã‚Œã‹ãŒå¿…è¦ã§ã™');
        
        if(drawingDataUrl && (drawingDataUrl.length * 0.75 > MAX_IMAGE_BYTES)) throw new Error(`ãŠçµµæãç”»åƒã®ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™ã€‚`);
        if(t.length>TITLE_LIMIT)throw new Error(`ã‚¿ã‚¤ãƒˆãƒ«ã¯${TITLE_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
        if(rawText.length>TEXT_LIMIT)throw new Error(`æœ¬æ–‡ã¯${TEXT_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
        if((rawText.match(/\n/g) || []).length > MAX_NEWLINES) throw new Error(`æ”¹è¡Œã¯${MAX_NEWLINES}å›ã¾ã§ã§ã™ã€‚`);
        if(rawText.match(new RegExp(`\\n{${MAX_CONSECUTIVE_NEWLINES + 1},}`))) throw new Error(`é€£ç¶šã—ãŸæ”¹è¡Œã¯${MAX_CONSECUTIVE_NEWLINES}å›ã¾ã§ã§ã™ã€‚`);
        if(n.length>NAME_LIMIT)throw new Error(`åå‰ã¯${NAME_LIMIT}æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„ã€‚`);
        if(containsNGWord(t)||containsNGWord(x)||containsNGWord(n))throw new Error('ä¸é©åˆ‡ãªå˜èªãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚');

        if (postDataProcessed.isEffectCommandUsed) {
          unlockAchievement(u_initial.permanentId, 'eye_puyuyu');
        }

        b.disabled=true;b.textContent='ä½œæˆä¸­...';
        
        const i = drawingDataUrl ? drawingDataUrl : (f ? await readFileAsDataURL(f) : null);
        
        let previewImg = null;
        if (i) {
            try {
                previewImg = await createThumbnail(i, 60, 60);
            } catch (thumbError) {
                console.error("ã‚µãƒ ãƒã‚¤ãƒ«ã®ä½œæˆã«å¤±æ•—:", thumbError);
                previewImg = null;
            }
        }
        
        const tags=t.match(/#[\p{L}\p{N}_]+/ug)?.map(tag=>tag.substring(1))||[];
        const now = firebase.database.ServerValue.TIMESTAMP;
        
        const finalAuthor = { permanentId: u_initial.permanentId, id: u_initial.id, name: finalName };
        
        const firstPost = {author: finalAuthor, text:x, img:i, createdAt:now};
        if(postDataProcessed.effect) firstPost.effect = postDataProcessed.effect;
        if(postDataProcessed.isCommandPost) firstPost.isCommandPost = true;

        const newThreadData={title:t, createdAt:now, lastUpdatedAt:now, op: finalAuthor, tags:tags, previewImg: previewImg};
        if (levelRestriction > 0) newThreadData.levelRestriction = levelRestriction;
        
        const createPost = functions.httpsCallable('createPost');
        const result = await createPost({
            isNewThread: true,
            threadData: newThreadData,
            postData: firstPost
        });

        let currentActivity = loadDailyActivity();
        const todayStr = getJstDateString();
        currentActivity.date === todayStr ? currentActivity.postCount++ : currentActivity = { date: todayStr, postCount: 1 };
        saveDailyActivity(currentActivity);
        
        localStorage.setItem(LAST_POST_TIME_KEY, Date.now().toString());
        if(postDataProcessed.isEffectCommandUsed) localStorage.setItem(EFFECT_COOLDOWN_KEY, Date.now().toString());
        
        drawingDataUrl = null;
        closeCreateModal();
        location.hash='thread-'+result.data.threadId;
      }catch(e){
        if (e.message !== 'å¤©æ°—æƒ…å ±å–å¾—å¤±æ•—') {
            alert('ã‚¨ãƒ©ãƒ¼: '+ (e.details ? e.details.message : e.message));
        }
      } finally {
        if(b){b.disabled=false;b.textContent='ã‚¹ãƒ¬ä½œæˆ';}
      }
    };
// â–²â–²â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–²â–²â–²

  applyTheme(localStorage.getItem(THEME_KEY)||'light');
  window.addEventListener('hashchange', renderApp);
  
  awardDailyBonusIfNeeded();
  
  setInterval(() => {
    document.querySelectorAll('.vote-countdown').forEach(el => {
      const timeLeft = parseInt(el.dataset.deadline, 10) - Date.now();
      const newText = formatTimeLeft(timeLeft);
      if (el.textContent !== newText) el.textContent = newText;
      if (timeLeft <= 0) el.classList.remove('vote-countdown');
    });
  }, 1000);

  renderApp();

  document.body.addEventListener('click', async (e) => {
    const target = e.target.closest('[data-action]');
    if (!target) return;
    const { action, threadId, postId, reac, name, id, isopadm, num, voteOption, dailyId, postTimestamp } = target.dataset;
    if (action === 'react') window.react(threadId, postId, reac);
    else if (action === 'delete-post') window.deletePost(threadId, postId);
    else if (action === 'edit-post') window.editPost(threadId, postId);
    else if (action === 'show-profile') window.showUserProfile(name, id, isopadm === 'true', dailyId, postTimestamp, threadId);
    else if (action === 'open-lightbox') { lightbox.style.display='flex'; document.getElementById('lightboxImage').src=target.src; }
    else if (action === 'delete-thread') {
        if(confirm('æœ¬å½“ã«ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚')){
            try {
                const deleteThreadFunction = functions.httpsCallable('deleteThread');
                const result = await deleteThreadFunction({ threadId: threadId });
                if (result.data.success) {
                    alert(result.data.message);
                    allThreads = allThreads.filter(t => t.id !== threadId);
                    goHome();
                } else {
                    throw new Error(result.data.message || "ã‚µãƒ¼ãƒãƒ¼å´ã§å‰Šé™¤ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚");
                }
            } catch (err) {
                console.error("ã‚¹ãƒ¬ãƒƒãƒ‰å‰Šé™¤ã‚¨ãƒ©ãƒ¼:", err);
                const errorMessage = err.details ? err.details.message : err.message;
                alert('ã‚¹ãƒ¬ãƒƒãƒ‰ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + (errorMessage || "ä¸æ˜ãªã‚¨ãƒ©ãƒ¼ã§ã™ã€‚"));
            }
        }
    }
    else if (action === 'quote') { 
        e.preventDefault();
        const targetPostNum = parseInt(num, 10);
        const currentThreadId = location.hash.replace('#thread-','');
        try {
            const posts = (await db.ref(`threads/${currentThreadId}/posts`).once('value')).val() || {};
            const targetPost = Object.values(posts).sort((a,b) => a.createdAt - b.createdAt)[targetPostNum - 1];
            if (targetPost) {
                const targetElement = document.querySelector(`[data-post-id="${targetPost.id}"]`);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    targetElement.style.transition = 'background-color 0.5s';
                    targetElement.style.backgroundColor = 'rgba(21,101,192,0.1)';
                    setTimeout(() => { targetElement.style.backgroundColor = ''; }, 2000);
                }
            } else {
                alert(`æŠ•ç¨¿ No.${targetPostNum} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`);
            }
        } catch (err) {
            alert('æŠ•ç¨¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + err.message);
        }
    }
    else if (action === 'insert-quote-number') { 
        e.preventDefault();
        const replyTextarea = document.getElementById('replyText');
        if (replyTextarea) {
            replyTextarea.value += `>>${parseInt(num, 10)} `;
            replyTextarea.focus();
        }
    }
    else if (action === 'vote') window.castVote(threadId, postId, voteOption);
    else if (action === 'show-anchors') window.showAnchors(postId, threadId);
    else if (action === 'jump-to-post') {
        e.preventDefault();
        const postId = target.dataset.postId;
        const threadId = new URL(target.href).hash.replace('#thread-', '');
        
        location.hash = '#thread-' + threadId;

        setTimeout(() => {
            const postElement = document.querySelector(`.post[data-post-id="${postId}"]`);
            if (postElement) {
                postElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                postElement.style.transition = 'background-color 0.5s';
                postElement.style.backgroundColor = 'rgba(255, 255, 0, 0.5)';
                setTimeout(() => {
                    postElement.style.backgroundColor = '';
                }, 3000);
            }
        }, 800);
    }
  });
}
</script>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</body>

</html>
